import{av as K,aw as D,ae as Y,ag as Z}from"./web3-errors-484f11ce.js";import{T as Q,B as v}from"./web3-types-ce0eb23a.js";import{v as ee}from"./is-my-json-valid-2c93b9e3.js";import{u as E,k as F,c as te}from"./ethereum-cryptography-7a8fc714.js";const se=["bool","int","uint","bytes","string","address","tuple"],H=e=>typeof e=="object"&&"type"in e&&"name"in e,re=e=>typeof e=="string",u=e=>typeof e=="string"&&/^((-)?0x[0-9a-f]+|(0x))$/i.test(e);function de(e,t){return!(typeof e!="string"||!e.match(/^0x[0-9A-Fa-f]*$/)||typeof t<"u"&&t>0&&e.length!==2+2*t)}const pe=e=>typeof e=="number"||typeof e=="bigint"||typeof e=="string"&&/^((-0x|0x|-)?[0-9a-f]+|(0x))$/i.test(e);function ge(e){if(typeof e!="string")throw new Error(`[isHexPrefixed] input must be type 'string', received type ${typeof e}`);return e.startsWith("0x")}const be=function(e){for(const[t,s]of Object.entries(e))if(s!==void 0&&s.length>0&&s[0]===0)throw new Error(`${t} cannot have leading zeroes, received: ${s.toString()}`)},p=e=>e==null,Ie=e=>typeof e=="object"&&!p(e)&&!Array.isArray(e)&&!(e instanceof Q),ie=e=>e.message&&e.instancePath&&e.params&&!p(e.params.value)?`value "${e.params.value}" at "${e.instancePath}" ${e.message}`:e.message&&e.instancePath?`value at "${e.instancePath}" ${e.message}`:e.instancePath?`value at "${e.instancePath}" caused unspecified error`:e.message?e.message:"unspecified error";class T extends K{constructor(t){super(),this.code=D,this.errors=t,super.message=`Web3 validator found ${t.length} error[s]:
${this._compileErrors().join(`
`)}`}_compileErrors(){return this.errors.map(ie)}}const ne=["hex","number","blockNumber","blockNumberOrTag","filter","bloom"],b=e=>{let t=e.replace(/ /,""),s,i=!1,r=[];if(e.includes("[")&&(t=t.slice(0,t.indexOf("[")),r=[...e.matchAll(/(?:\[(\d*)\])/g)].map(n=>parseInt(n[1],10)).map(n=>Number.isNaN(n)?-1:n),i=r.length>0),se.includes(t))return{baseType:t,isArray:i,baseTypeSize:s,arraySizes:r};if(t.startsWith("int"))s=parseInt(t.substring(3),10),t="int";else if(t.startsWith("uint"))s=parseInt(e.substring(4),10),t="uint";else if(t.startsWith("bytes"))s=parseInt(t.substring(5),10),t="bytes";else return{baseType:void 0,isArray:!1,baseTypeSize:void 0,arraySizes:r};return{baseType:t,isArray:i,baseTypeSize:s,arraySizes:r}},B=(e,t={})=>{if(Object.keys(t).includes("type"))throw new T([{keyword:"eth",message:'Either "eth" or "type" can be presented in schema',params:{eth:e},instancePath:"",schemaPath:""}]);const{baseType:i,baseTypeSize:r}=b(e);if(!i&&!ne.includes(e))throw new T([{keyword:"eth",message:`Eth data type "${e}" is not valid`,params:{eth:e},instancePath:"",schemaPath:""}]);if(i){if(i==="tuple")throw new Error('"tuple" type is not implemented directly.');return{format:`${i}${r??""}`,required:!0}}return e?{format:e,required:!0}:{}},$=(e,t="/0")=>{const s={type:"array",items:[],maxItems:e.length,minItems:e.length};for(const[i,r]of e.entries()){let n,a,f=[];H(r)?(n=r.type,a=r.name,f=r.components):typeof r=="string"?(n=r,a=`${t}/${i}`):Array.isArray(r)&&(r[0]&&typeof r[0]=="string"&&r[0].startsWith("tuple")&&!Array.isArray(r[0])&&r[1]&&Array.isArray(r[1])?(n=r[0],a=`${t}/${i}`,f=r[1]):(n="tuple",a=`${t}/${i}`,f=r));const{baseType:c,isArray:y,arraySizes:m}=b(n);let h,l=s;for(let o=m.length-1;o>0;o-=1)h={type:"array",items:[],maxItems:m[o],minItems:m[o]},m[o]<0&&(delete h.maxItems,delete h.minItems),l.items=h,l=h;if(c==="tuple"&&!y){const o=$(f,a);o.$id=a,l.items.push(o)}else if(c==="tuple"&&y){const o=m[0],d={$id:a,type:"array",items:$(f,a),maxItems:o,minItems:o};o<0&&(delete d.maxItems,delete d.minItems),l.items.push(d)}else if(y){const o=m[0],d={type:"array",$id:a,items:B(String(c)),minItems:o,maxItems:o};o<0&&(delete d.maxItems,delete d.minItems),l.items.push(d)}else Array.isArray(l.items)?l.items.push(Object.assign({$id:a},B(n))):l.items.items.push(Object.assign({$id:a},B(n)))}return s},U=e=>$(e),O=(e,t)=>t===1?e:O(e[0],t-1),A=(e,t,s)=>{const i=[];for(const[r,n]of e.entries()){let a,f,c=[];H(n)?(a=n.type,f=n.name,c=n.components):typeof n=="string"?a=n:Array.isArray(n)&&(n[1]&&Array.isArray(n[1])?(a=n[0],c=n[1]):(a="tuple",c=n));const{baseType:y,isArray:m,arraySizes:h}=b(a),l=Array.isArray(t)?t[r]:t[f];if(y==="tuple"&&!m)i.push(A(c,l,s));else if(y==="tuple"&&m){const o=[];for(const d of l)if(h.length>1){const q=O(d,h.length-1),V=[];for(const G of q)V.push(A(c,G,s));o.push(V)}else o.push(A(c,d,s));i.push(o)}else i.push(l)}return s=s??[],s.push(...i),s},L=e=>{if(e>=48&&e<=57)return e-48;if(e>=65&&e<=70)return e-55;if(e>=97&&e<=102)return e-87;throw new Error(`Invalid code point: ${e}`)},z=e=>{if(!u(e))throw new Error("Invalid hex string");const[t,s]=e.startsWith("-")?[!0,e.slice(1)]:[!1,e],i=BigInt(s);return i>Number.MAX_SAFE_INTEGER?t?-i:i:i<Number.MIN_SAFE_INTEGER?i:t?-1*Number(i):Number(i)},P=e=>{if((typeof e=="number"||typeof e=="bigint")&&e<0)return`-0x${e.toString(16).slice(1)}`;if((typeof e=="number"||typeof e=="bigint")&&e>=0)return`0x${e.toString(16)}`;if(typeof e=="string"&&u(e)){const[t,s]=e.startsWith("-")?[!0,e.slice(1)]:[!1,e],i=s.split(/^(-)?0(x|X)/).slice(-1)[0];return`${t?"-":""}0x${i.replace(/^0+/,"").toLowerCase()}`}if(typeof e=="string"&&!u(e))return P(BigInt(e));throw new Z(e)},M=(e,t,s="0")=>{if(typeof e=="string"&&!u(e))return e.padStart(t,s);const i=typeof e=="string"&&u(e)?e:P(e),[r,n]=i.startsWith("-")?["-0x",i.slice(3)]:["0x",i.slice(2)];return`${r}${n.padStart(t,s)}`};function w(e){let t="0x";for(const s of e){const i=s.toString(16);t+=i.length===1?`0${i}`:i}return t}function j(e){let t;if(e.toLowerCase().startsWith("0x")?t=e.slice(2):t=e,t.length%2!==0)throw new Y(`hex string has odd length: ${e}`);const s=new Uint8Array(Math.ceil(t.length/2));for(let i=0;i<s.length;i+=1){const r=parseInt(t.substring(i*2,i*2+2),16);s[i]=r}return s}const xe=Object.freeze(Object.defineProperty({__proto__:null,abiSchemaToJsonSchema:$,codePointToInt:L,ethAbiToJsonSchema:U,fetchArrayElement:O,hexToNumber:z,hexToUint8Array:j,numberToHex:P,padLeft:M,parseBaseType:b,transformJsonDataToAbiFormat:A,uint8ArrayToHexString:w},Symbol.toStringTag,{value:"Module"})),ae=e=>{if(!/^(0x)?[0-9a-f]{40}$/i.test(e))return!1;const t=e.slice(2),s=E.utf8ToBytes(t.toLowerCase()),i=w(F(s)).slice(2);for(let r=0;r<40;r+=1)if(parseInt(i[r],16)>7&&t[r].toUpperCase()!==t[r]||parseInt(i[r],16)<=7&&t[r].toLowerCase()!==t[r])return!1;return!0},I=(e,t=!0)=>{if(typeof e!="string"&&!(e instanceof Uint8Array))return!1;let s;return e instanceof Uint8Array?s=w(e):typeof e=="string"&&!u(e)?s=e.toLowerCase().startsWith("0x")?e:`0x${e}`:s=e,/^(0x)?[0-9a-f]{40}$/i.test(s)?/^(0x|0X)?[0-9a-f]{40}$/.test(s)||/^(0x|0X)?[0-9A-F]{40}$/.test(s)?!0:t?ae(s):!0:!1},_=(e,t={abiType:"uint"})=>{if(!["number","string","bigint"].includes(typeof e)||typeof e=="string"&&e.length===0)return!1;let s;if(t!=null&&t.abiType){const{baseTypeSize:r}=b(t.abiType);r&&(s=r)}else t.bitSize&&(s=t.bitSize);const i=BigInt(2)**BigInt(s??256)-BigInt(1);try{const r=typeof e=="string"&&u(e)?BigInt(z(e)):BigInt(e);return r>=0&&r<=i}catch{return!1}},C=(e,t={abiType:"int"})=>{if(!["number","string","bigint"].includes(typeof e)||typeof e=="number"&&e>Number.MAX_SAFE_INTEGER)return!1;let s;if(t!=null&&t.abiType){const{baseTypeSize:n,baseType:a}=b(t.abiType);if(a!=="int")return!1;n&&(s=n)}else t.bitSize&&(s=t.bitSize);const i=BigInt(2)**BigInt((s??256)-1),r=BigInt(-1)*BigInt(2)**BigInt((s??256)-1);try{const n=typeof e=="string"&&u(e)?BigInt(z(e)):BigInt(e);return n>=r&&n<=i}catch{return!1}},oe=e=>!!(C(e)||typeof e=="string"&&/[0-9.]/.test(e)&&e.indexOf(".")===e.lastIndexOf(".")||typeof e=="number"),J=e=>_(e),R=e=>Object.values(v).includes(e),k=e=>R(e)||J(e),x=e=>typeof e!="string"||!/^(0x)?[0-9a-f]{512}$/i.test(e)?!1:!!(/^(0x)?[0-9a-f]{512}$/.test(e)||/^(0x)?[0-9A-F]{512}$/.test(e)),W=(e,t)=>{if(typeof t=="string"&&!u(t)||!x(e))return!1;const s=typeof t=="string"?j(t):t,i=w(F(s)).slice(2);for(let r=0;r<12;r+=4){const n=(parseInt(i.slice(r,r+2),16)<<8)+parseInt(i.slice(r+2,r+4),16)&2047,a=L(e.charCodeAt(e.length-1-Math.floor(n/4))),f=1<<n%4;if((a&f)!==f)return!1}return!0},Ae=(e,t)=>{if(!x(e)||!I(t))return!1;const s=M(t,64);return W(e,s)},Te=(e,t)=>!x(e)||!I(t)?!1:W(e,t),fe=e=>["number","string","boolean"].includes(typeof e)?typeof e=="boolean"?!0:typeof e=="string"&&!u(e)?e==="1"||e==="0":typeof e=="string"&&u(e)?e==="0x1"||e==="0x0":typeof e=="number"?e===1||e===0:!1:!1,X=(e,t={abiType:"bytes"})=>{if(typeof e!="string"&&!Array.isArray(e)&&!(e instanceof Uint8Array)||typeof e=="string"&&u(e)&&e.startsWith("-")||typeof e=="string"&&!u(e))return!1;let s;if(typeof e=="string"){if(e.length%2!==0)return!1;s=j(e)}else if(Array.isArray(e)){if(e.some(i=>i<0||i>255||!Number.isInteger(i)))return!1;s=new Uint8Array(e)}else s=e;if(t!=null&&t.abiType){const{baseTypeSize:i}=b(t.abiType);return i?s.length===i:!0}return t!=null&&t.size?s.length===(t==null?void 0:t.size):!0},N=e=>typeof e!="string"||!/^(0x)?[0-9a-f]{64}$/i.test(e)?!1:!!(/^(0x)?[0-9a-f]{64}$/.test(e)||/^(0x)?[0-9A-F]{64}$/.test(e)),$e=(e,t)=>!x(e)||!N(t)?!1:W(e,t),ce=e=>{const t=["fromBlock","toBlock","address","topics"];if(p(e)||typeof e!="object"||!Object.keys(e).every(s=>t.includes(s))||!p(e.fromBlock)&&!k(e.fromBlock)||!p(e.toBlock)&&!k(e.toBlock))return!1;if(!p(e.address)){if(Array.isArray(e.address)){if(!e.address.every(s=>I(s)))return!1}else if(!I(e.address))return!1}return!(!p(e.topics)&&!e.topics.every(s=>p(s)?!0:Array.isArray(s)?s.every(i=>N(i)):!!N(s)))},S={address:e=>I(e),bloom:e=>x(e),blockNumber:e=>J(e),blockTag:e=>R(e),blockNumberOrTag:e=>k(e),bool:e=>fe(e),bytes:e=>X(e),filter:e=>ce(e),hex:e=>u(e),uint:e=>_(e),int:e=>C(e),number:e=>oe(e),string:e=>re(e)};for(let e=3;e<=8;e+=1){const t=2**e;S[`int${t}`]=s=>C(s,{bitSize:t}),S[`uint${t}`]=s=>_(s,{bitSize:t})}for(let e=1;e<=32;e+=1)S[`bytes${e}`]=t=>X(t,{size:e});class g{constructor(){this._schemas=new Map}static factory(){return g.validatorInstance||(g.validatorInstance=new g),g.validatorInstance}getSchema(t){return this._schemas.get(t)}addSchema(t,s){this._schemas.set(t,this.createValidator(s))}createValidator(t){return ee(t,{formats:S,greedy:!0,verbose:!0,additionalProperties:!1})}validate(t,s,i){const r=this.getOrCreateValidator(t);if(!r(s)){const n=this.convertErrors(r.errors,t,s);if(n){if(i!=null&&i.silent)return n;throw new T(n)}}}convertErrors(t,s,i){if(t&&Array.isArray(t)&&t.length>0)return t.map(r=>{let n,a,f,c;c=Array.isArray(r.schemaPath)?r.schemaPath.slice(1).join("/"):"";const{field:y}=r,m=c||((y==null?void 0:y.length)>=4?`${y.slice(4).replace(/\"|\[|\]/g,"")}`:"/"),h=m?`/${m}`:"";if((r==null?void 0:r.message)==="has less items than allowed"){const o=this.getObjectValueByPath(s,c);o.minItems&&(a="minItems",c=`${c}/minItems`,f={limit:o.minItems},n=`must NOT have fewer than ${o.minItems} items`)}else if((r==null?void 0:r.message)==="has more items than allowed"){const o=this.getObjectValueByPath(s,c);o.maxItems&&(a="maxItems",c=`${c}/maxItems`,f={limit:o.maxItems},n=`must NOT have more than ${o.maxItems} items`)}else if(r!=null&&r.message.startsWith("must be")&&(r!=null&&r.message.endsWith("format"))){const o=r==null?void 0:r.message.split(" ")[2];o&&(n=`must pass "${o}" validation`)}const l=this.getObjectValueByPath(i,h);return{keyword:a??r.field,instancePath:h,schemaPath:`#${c}`,params:f??{value:l},message:n??r.message}})}getOrCreateValidator(t){const s=g.getKey(t);let i=this.getSchema(s);return i||(this.addSchema(s,t),i=this.getSchema(s)),i}static getKey(t){return E.toHex(te(E.utf8ToBytes(JSON.stringify(t))))}getObjectValueByPath(t,s,i){try{if(typeof t!="object")throw new Error("Invalid input object");if(typeof s!="string")throw new Error("Invalid JSON pointer");const r=s.split("/");if(!["","#"].includes(r.shift()))throw new Error("Invalid JSON pointer");if(r.length===0)return t;let n=t;for(const a of r){if(typeof a!="string")throw new Error("Invalid JSON pointer");i&&i.push(n);const f=this.untilde(a);if(typeof n!="object"||!Object.prototype.hasOwnProperty.call(n,f))return;n=n[f]}return n}catch{return""}}untilde(t){return t.includes("~")?t.replace(/~[01]/g,s=>{switch(s){case"~1":return"/";case"~0":return"~";default:throw new Error("Unreachable")}}):t}}class le{constructor(){this._validator=g.factory()}validateJSONSchema(t,s,i){return this._validator.validate(t,s,i)}validate(t,s,i={silent:!1}){var r,n;const a=U(t);if(!(Array.isArray(a.items)&&((r=a.items)===null||r===void 0?void 0:r.length)===0&&s.length===0)){if(Array.isArray(a.items)&&((n=a.items)===null||n===void 0?void 0:n.length)===0&&s.length!==0)throw new T([{instancePath:"/0",schemaPath:"/",keyword:"required",message:"empty schema against data can not be validated",params:s}]);return this._validator.validate(a,s,i)}}}const Se=new le;export{M as A,Ie as B,U as C,T as W,I as a,u as b,oe as c,R as d,X as e,re as f,_ as g,de as h,p as i,ge as j,be as k,j as l,z as m,P as n,pe as o,C as p,ae as q,x as r,W as s,A as t,xe as u,Se as v,Ae as w,Te as x,N as y,$e as z};
