const I=u=>(o,a,n)=>{const l=n.subscribe;return n.subscribe=(h,d,c)=>{let i=h;if(d){const v=(c==null?void 0:c.equalityFn)||Object.is;let S=h(n.getState());i=E=>{const m=h(E);if(!v(S,m)){const b=S;d(S=m,b)}},c!=null&&c.fireImmediately&&d(S,S)}return l(i)},u(o,a,n)},A=I;function _(u,o){let a;try{a=u()}catch{return}return{getItem:l=>{var e;const h=c=>c===null?null:JSON.parse(c,o==null?void 0:o.reviver),d=(e=a.getItem(l))!=null?e:null;return d instanceof Promise?d.then(h):h(d)},setItem:(l,e)=>a.setItem(l,JSON.stringify(e,o==null?void 0:o.replacer)),removeItem:l=>a.removeItem(l)}}const y=u=>o=>{try{const a=u(o);return a instanceof Promise?a:{then(n){return y(n)(a)},catch(n){return this}}}catch(a){return{then(n){return this},catch(n){return y(n)(a)}}}},R=(u,o)=>(a,n,l)=>{let e={getStorage:()=>localStorage,serialize:JSON.stringify,deserialize:JSON.parse,partialize:r=>r,version:0,merge:(r,f)=>({...f,...r}),...o},h=!1;const d=new Set,c=new Set;let i;try{i=e.getStorage()}catch{}if(!i)return u((...r)=>{console.warn(`[zustand persist middleware] Unable to update item '${e.name}', the given storage is currently unavailable.`),a(...r)},n,l);const v=y(e.serialize),S=()=>{const r=e.partialize({...n()});let f;const t=v({state:r,version:e.version}).then(g=>i.setItem(e.name,g)).catch(g=>{f=g});if(f)throw f;return t},E=l.setState;l.setState=(r,f)=>{E(r,f),S()};const m=u((...r)=>{a(...r),S()},n,l);let b;const s=()=>{var r;if(!i)return;h=!1,d.forEach(t=>t(n()));const f=((r=e.onRehydrateStorage)==null?void 0:r.call(e,n()))||void 0;return y(i.getItem.bind(i))(e.name).then(t=>{if(t)return e.deserialize(t)}).then(t=>{if(t)if(typeof t.version=="number"&&t.version!==e.version){if(e.migrate)return e.migrate(t.state,t.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return t.state}).then(t=>{var g;return b=e.merge(t,(g=n())!=null?g:m),a(b,!0),S()}).then(()=>{f==null||f(b,void 0),h=!0,c.forEach(t=>t(b))}).catch(t=>{f==null||f(void 0,t)})};return l.persist={setOptions:r=>{e={...e,...r},r.getStorage&&(i=r.getStorage())},clearStorage:()=>{i==null||i.removeItem(e.name)},getOptions:()=>e,rehydrate:()=>s(),hasHydrated:()=>h,onHydrate:r=>(d.add(r),()=>{d.delete(r)}),onFinishHydration:r=>(c.add(r),()=>{c.delete(r)})},s(),b||m},p=(u,o)=>(a,n,l)=>{let e={storage:_(()=>localStorage),partialize:s=>s,version:0,merge:(s,r)=>({...r,...s}),...o},h=!1;const d=new Set,c=new Set;let i=e.storage;if(!i)return u((...s)=>{console.warn(`[zustand persist middleware] Unable to update item '${e.name}', the given storage is currently unavailable.`),a(...s)},n,l);const v=()=>{const s=e.partialize({...n()});return i.setItem(e.name,{state:s,version:e.version})},S=l.setState;l.setState=(s,r)=>{S(s,r),v()};const E=u((...s)=>{a(...s),v()},n,l);let m;const b=()=>{var s,r;if(!i)return;h=!1,d.forEach(t=>{var g;return t((g=n())!=null?g:E)});const f=((r=e.onRehydrateStorage)==null?void 0:r.call(e,(s=n())!=null?s:E))||void 0;return y(i.getItem.bind(i))(e.name).then(t=>{if(t)if(typeof t.version=="number"&&t.version!==e.version){if(e.migrate)return e.migrate(t.state,t.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return t.state}).then(t=>{var g;return m=e.merge(t,(g=n())!=null?g:E),a(m,!0),v()}).then(()=>{f==null||f(m,void 0),m=n(),h=!0,c.forEach(t=>t(m))}).catch(t=>{f==null||f(void 0,t)})};return l.persist={setOptions:s=>{e={...e,...s},s.storage&&(i=s.storage)},clearStorage:()=>{i==null||i.removeItem(e.name)},getOptions:()=>e,rehydrate:()=>b(),hasHydrated:()=>h,onHydrate:s=>(d.add(s),()=>{d.delete(s)}),onFinishHydration:s=>(c.add(s),()=>{c.delete(s)})},e.skipHydration||b(),m||E},T=(u,o)=>"getStorage"in o||"serialize"in o||"deserialize"in o?(({VITE_API_URL:"http://localhost:8000",VITE_URL:"http://localhost:5173",VITE_TOKEN_ADDRESS:"0x55d398326f99059ff775485246999027b3197955",VITE_SMART_CONTRACT_ADDRESS:"0x49010eF4084CDCbb697a39f29aD4D1706090D4Be",VITE_MAIN_WALLET_ADDRESS:"0x4240ED0D6ef9a25FD36066CE7e8009DB6F4780B8",BASE_URL:"/",MODE:"production",DEV:!1,PROD:!0,SSR:!1}&&"production")!=="production"&&console.warn("[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."),R(u,o)):p(u,o),C=T,D=u=>{let o;const a=new Set,n=(c,i)=>{const v=typeof c=="function"?c(o):c;if(!Object.is(v,o)){const S=o;o=i??typeof v!="object"?v:Object.assign({},o,v),a.forEach(E=>E(o,S))}},l=()=>o,d={setState:n,getState:l,subscribe:c=>(a.add(c),()=>a.delete(c)),destroy:()=>{({VITE_API_URL:"http://localhost:8000",VITE_URL:"http://localhost:5173",VITE_TOKEN_ADDRESS:"0x55d398326f99059ff775485246999027b3197955",VITE_SMART_CONTRACT_ADDRESS:"0x49010eF4084CDCbb697a39f29aD4D1706090D4Be",VITE_MAIN_WALLET_ADDRESS:"0x4240ED0D6ef9a25FD36066CE7e8009DB6F4780B8",BASE_URL:"/",MODE:"production",DEV:!1,PROD:!0,SSR:!1}&&"production")!=="production"&&console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."),a.clear()}};return o=u(n,l,d),d},w=u=>u?D(u):D;export{w as c,C as p,A as s};
