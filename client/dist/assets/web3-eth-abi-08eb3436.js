import{V as y}from"./web3-errors-484f11ce.js";import{i as p,y as B,t as W,z,A as j}from"./web3-utils-f506bce1.js";import{A as R,P as h}from"./@ethersproject-c3cfd277.js";const b=new R((e,t)=>t!=null&&t._isBigNumber?t.toBigInt():t),q=e=>!p(e)&&typeof e=="object"&&!p(e.type)&&["function","event","constructor","error"].includes(e.type),w=e=>!p(e)&&typeof e=="object"&&!p(e.type)&&e.type==="error",I=e=>!p(e)&&typeof e=="object"&&!p(e.type)&&e.type==="event",x=e=>!p(e)&&typeof e=="object"&&!p(e.type)&&e.type==="function",K=e=>!p(e)&&typeof e=="object"&&!p(e.type)&&e.type==="constructor",H=e=>typeof e=="object"&&typeof e.components>"u"&&typeof e.name>"u",P=e=>e.includes("[]")?{type:"tuple[]",name:e.slice(0,-2)}:{type:"tuple",name:e},$=e=>{const t=[];for(const n of Object.keys(e)){const r=e[n];typeof r=="object"?t.push(Object.assign(Object.assign({},P(n)),{components:$(r)})):t.push({name:n,type:e[n]})}return t},S=e=>{const t=[];for(const n of e){let r=n;if(typeof n=="object"&&(r=Object.assign({},n)),typeof n=="object"&&n.type==="function"&&(r=Object.assign(Object.assign({},n),{type:"bytes24"})),H(r)){const o=Object.keys(r)[0];t.push(Object.assign(Object.assign({},P(o)),{components:$(r[o])}))}else t.push(r)}return t},V=e=>typeof e=="string"&&/^(-)?0x[0-9a-f]*$/i.test(e)&&e.length%2===1,O=e=>V(e)?`0x0${e.substring(2)}`:e,_=(e,t)=>{var n;const r=typeof t=="object"&&!Array.isArray(t)?Object.assign({},t):t,o=/^bytes([0-9]*)$/,c=/^bytes([0-9]*)\[\]$/,s=/^(u?int)([0-9]*)$/,d=/^(u?int)([0-9]*)\[\]$/;if(r instanceof BigInt)return r.toString(10);if(c.exec(e)||d.exec(e))return[...r].map(u=>_(e.replace("[]",""),u));let l=s.exec(e);if(l){const i=parseInt((n=l[2])!==null&&n!==void 0?n:"256",10);if(i/8<r.length)return B(r,i)}if(l=o.exec(e),l){const i=r instanceof Uint8Array?W(r):r,u=parseInt(l[1],10);if(u){let g=u*2;r.startsWith("0x")&&(g+=2);const a=i.length<g?z(r,u*2):i;return O(a)}return O(i)}return r},v=(e,t)=>e.name==="array"?t.map(n=>v(b._getCoder(h.from(e.type.replace("[]",""))),[n])):(e.coders.forEach((n,r)=>{n.name==="tuple"?v(n,[t[r]]):t[r]=_(n.name,t[r])}),[]),A=(e,t)=>{const n=[];return t.forEach(r=>{if(typeof r.components=="object"){if(!r.type.startsWith("tuple"))throw new y(`Invalid value given "${r.type}". Error: components found but type is not tuple.`);const o=r.type.indexOf("["),c=o>=0?r.type.substring(o):"",s=A(e,r.components);Array.isArray(s)&&e?n.push(`tuple(${s.join(",")})${c}`):e?n.push(`(${s.join()})`):n.push(`(${s.join(",")})${c}`)}else n.push(r.type)}),n},m=e=>{var t,n,r,o;return w(e)||I(e)||x(e)?!((t=e.name)===null||t===void 0)&&t.includes("(")?e.name:`${(n=e.name)!==null&&n!==void 0?n:""}(${A(!1,(r=e.inputs)!==null&&r!==void 0?r:[]).join(",")})`:`(${A(!1,(o=e.inputs)!==null&&o!==void 0?o:[]).join(",")})`},D=e=>{if(typeof e!="string"&&!w(e))throw new y("Invalid parameter value in encodeErrorSignature");let t;return e&&(typeof e=="function"||typeof e=="object")?t=m(e):t=e,j(t)},Q=e=>{if(typeof e!="string"&&!I(e))throw new y("Invalid parameter value in encodeEventSignature");let t;return e&&(typeof e=="function"||typeof e=="object")?t=m(e):t=e,j(t)},T=(e,t)=>{try{const n=S(Array.isArray(e)?e:[e]),r=[];for(const[o,c]of t.entries()){const s=n[o];let d;q(s)&&s.type?d=s.type:d=s;const l=_(d,c);if(typeof d=="string"&&d.includes("tuple")){const i=b._getCoder(h.from(d));v(i,[l])}r.push(l)}return b.encode(n.map(o=>h.from(o)),r)}catch(n){throw new y("Parameter encoding error",n)}},Z=(e,t)=>T([e],[t]),Y=e=>Array.isArray(e)&&Object.keys(e).filter(t=>Number.isInteger(+t)).length!==Object.keys(e).length,C=e=>{const t={__length__:0};for(const n of Object.keys(e))t[n]=Array.isArray(e[n])&&Y(e[n])?C(e[n]):e[n],t.__length__+=Number.isInteger(+n)?1:0;return t},E=(e,t,n)=>{try{if(e.length>0&&(!t||t==="0x"||t==="0X"))throw new y("Returned values aren't valid, did it run Out of Gas? You might also see this error if you are not using the correct ABI for the contract you are retrieving data from, requesting data from a block number that does not exist, or querying a node which is not fully synced.");const r=b.decode(S(e).map(o=>h.from(o)),`0x${t.replace(/0x/i,"")}`,n);return C(r)}catch(r){throw new y(`Parameter decoding error: ${r.message}`)}},F=(e,t)=>E(e,t,!1),G=(e,t)=>F([e],t)[0],L=e=>{if(typeof e!="string"&&!x(e))throw new y("Invalid parameter value in encodeFunctionSignature");let t;return e&&(typeof e=="function"||typeof e=="object")?t=m(e):t=e,j(t).slice(0,10)},N=(e,t)=>{var n;if(!x(e))throw new y("Invalid parameter value in encodeFunctionCall");return`${L(e)}${T((n=e.inputs)!==null&&n!==void 0?n:[],t??[]).replace("0x","")}`},M=["bool","string","int","uint","address","fixed","ufixed"],ee=(e,t,n)=>{const r=Array.isArray(n)?n:[n],o={},c={};for(const[a,f]of e.entries())f.indexed?o[a]=f:c[a]=f;const s=t?E(Object.values(c),t,!0):{__length__:0},d=r.length-Object.keys(o).length,l=Object.values(o).map((a,f)=>M.some(k=>a.type.startsWith(k))?G(a.type,r[f+d]):r[f+d]),i={__length__:0};let u=0,g=0;for(const[a,f]of e.entries())i[a]=f.type==="string"?"":void 0,o[a]&&(i[a]=l[u],u+=1),c[a]&&(i[a]=s[String(g)],g+=1),f.name&&(i[f.name]=i[a]),i.__length__+=1;return i},te=(e,t)=>{if(t!=null&&t.data){let n,r,o;try{const c=t.data.slice(0,10),s=e.find(d=>D(d).startsWith(c));s!=null&&s.inputs&&(n=s.name,r=m(s),o=F([...s.inputs],t.data.substring(10)))}catch(c){console.error(c)}n&&t.setDecodedProperties(n,r,o)}};export{N as a,L as b,Z as c,T as d,Q as e,G as f,F as g,ee as h,w as i,te as j,m as k,K as l,x as m,I as n};
