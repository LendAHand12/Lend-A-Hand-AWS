var T=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function U(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}function _(e){if(e.__esModule)return e;var t=e.default;if(typeof t=="function"){var r=function n(){if(this instanceof n){var o=[null];o.push.apply(o,arguments);var i=Function.bind.apply(t,o);return new i}return t.apply(this,arguments)};r.prototype=t.prototype}else r={};return Object.defineProperty(r,"__esModule",{value:!0}),Object.keys(e).forEach(function(n){var o=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(r,n,o.get?o:{enumerable:!0,get:function(){return e[n]}})}),r}var l={};Object.defineProperty(l,"__esModule",{value:!0});var v=l.RLP=l.utils=l.decode=l.encode=void 0;function y(e){if(Array.isArray(e)){const r=[];let n=0;for(let o=0;o<e.length;o++){const i=y(e[o]);r.push(i),n+=i.length}return h(p(n,192),...r)}const t=L(e);return t.length===1&&t[0]<128?t:h(p(t.length,128),t)}l.encode=y;function d(e,t,r){if(r>e.length)throw new Error("invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds");return e.slice(t,r)}function w(e){if(e[0]===0)throw new Error("invalid RLP: extra zeros");return x(b(e))}function p(e,t){if(e<56)return Uint8Array.from([e+t]);const r=g(e),n=r.length/2,o=g(t+55+n);return Uint8Array.from(u(o+r))}function m(e,t=!1){if(typeof e>"u"||e===null||e.length===0)return Uint8Array.from([]);const r=L(e),n=c(r);if(t)return n;if(n.remainder.length!==0)throw new Error("invalid RLP: remainder must be zero");return n.data}l.decode=m;function c(e){let t,r,n,o,i;const a=[],f=e[0];if(f<=127)return{data:e.slice(0,1),remainder:e.slice(1)};if(f<=183){if(t=f-127,f===128?n=Uint8Array.from([]):n=d(e,1,t),t===2&&n[0]<128)throw new Error("invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed");return{data:n,remainder:e.slice(t)}}else if(f<=191){if(r=f-182,e.length-1<r)throw new Error("invalid RLP: not enough bytes for string length");if(t=w(d(e,1,r)),t<=55)throw new Error("invalid RLP: expected string length to be greater than 55");return n=d(e,r,t+r),{data:n,remainder:e.slice(t+r)}}else if(f<=247){for(t=f-191,o=d(e,1,t);o.length;)i=c(o),a.push(i.data),o=i.remainder;return{data:a,remainder:e.slice(t)}}else{if(r=f-246,t=w(d(e,1,r)),t<56)throw new Error("invalid RLP: encoded list too short");const s=r+t;if(s>e.length)throw new Error("invalid RLP: total length is larger than the data");for(o=d(e,r,s);o.length;)i=c(o),a.push(i.data),o=i.remainder;return{data:a,remainder:e.slice(s)}}}const A=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function b(e){let t="";for(let r=0;r<e.length;r++)t+=A[e[r]];return t}function x(e){const t=Number.parseInt(e,16);if(Number.isNaN(t))throw new Error("Invalid byte sequence");return t}function u(e){if(typeof e!="string")throw new TypeError("hexToBytes: expected string, got "+typeof e);if(e.length%2)throw new Error("hexToBytes: received invalid unpadded hex");const t=new Uint8Array(e.length/2);for(let r=0;r<t.length;r++){const n=r*2;t[r]=x(e.slice(n,n+2))}return t}function h(...e){if(e.length===1)return e[0];const t=e.reduce((n,o)=>n+o.length,0),r=new Uint8Array(t);for(let n=0,o=0;n<e.length;n++){const i=e[n];r.set(i,o),o+=i.length}return r}function P(e){return new TextEncoder().encode(e)}function g(e){if(e<0)throw new Error("Invalid integer as argument, must be unsigned!");const t=e.toString(16);return t.length%2?`0${t}`:t}function R(e){return e.length%2?`0${e}`:e}function E(e){return e.length>=2&&e[0]==="0"&&e[1]==="x"}function B(e){return typeof e!="string"?e:E(e)?e.slice(2):e}function L(e){if(e instanceof Uint8Array)return e;if(typeof e=="string")return E(e)?u(R(B(e))):P(e);if(typeof e=="number"||typeof e=="bigint")return e?u(g(e)):Uint8Array.from([]);if(e==null)return Uint8Array.from([]);throw new Error("toBytes: received unsupported type "+typeof e)}l.utils={bytesToHex:b,concatBytes:h,hexToBytes:u,utf8ToBytes:P};v=l.RLP={encode:y,decode:m};export{v as R,_ as a,T as c,U as g};
