import{p as Ue}from"./crc-32-91e6c902.js";import{e as ze}from"./events-f5832a60.js";import"./is-my-json-valid-2c93b9e3.js";import{i as D,h as Pe,j as ce,k as de,b as Se,f as $e,v as ge}from"./web3-validator-6b520267.js";import{W as Ke,X as je,Y as qe,Z as Ve,_ as Je,$ as xe,a0 as pe,a1 as Ye,a2 as ie,a3 as Xe,a4 as We}from"./web3-errors-484f11ce.js";import{b as Ze}from"./web3-types-ce0eb23a.js";import{R as A}from"./@ethereumjs-a0310e2a.js";import{s as Qe,e as et,k as H,p as Be,a as Ae,b as tt,d as rt}from"./ethereum-cryptography-7a8fc714.js";import{n as P,s as Te,l as E,B as R,C as he,D as le,E as st,A as J,w as fe,F as ve,G as it,v as nt}from"./web3-utils-f506bce1.js";var $=globalThis&&globalThis.__awaiter||function(s,e,t,r){function i(n){return n instanceof t?n:new t(function(o){o(n)})}return new(t||(t=Promise))(function(n,o){function a(c){try{h(r.next(c))}catch(l){o(l)}}function d(c){try{h(r.throw(c))}catch(l){o(l)}}function h(c){c.done?n(c.value):i(c.value).then(a,d)}h((r=r.apply(s,e||[])).next())})};class ne extends Ze{constructor(){super(...arguments),this._addressMap=new Map,this._defaultKeyName="web3js_wallet"}static getStorage(){let e;try{e=window.localStorage;const t="__storage_test__";return e.setItem(t,t),e.removeItem(t),e}catch(t){return t&&(t.code===22||t.code===1014||t.name==="QuotaExceededError"||t.name==="NS_ERROR_DOM_QUOTA_REACHED")&&!D(e)&&e.length!==0?e:void 0}}create(e){for(let t=0;t<e;t+=1)this.add(this._accountProvider.create());return this}add(e){var t;if(typeof e=="string")return this.add(this._accountProvider.privateKeyToAccount(e));let r=this.length;return this.get(e.address)&&(console.warn(`Account ${e.address.toLowerCase()} already exists.`),r=(t=this._addressMap.get(e.address.toLowerCase()))!==null&&t!==void 0?t:r),this._addressMap.set(e.address.toLowerCase(),r),this[r]=e,this}get(e){if(typeof e=="string"){const t=this._addressMap.get(e.toLowerCase());return D(t)?void 0:this[t]}return this[e]}remove(e){if(typeof e=="string"){const t=this._addressMap.get(e.toLowerCase());return D(t)?!1:(this._addressMap.delete(e.toLowerCase()),this.splice(t,1),!0)}return this[e]?(this.splice(e,1),!0):!1}clear(){return this._addressMap.clear(),this.length=0,this}encrypt(e,t){return $(this,void 0,void 0,function*(){return Promise.all(this.map(r=>$(this,void 0,void 0,function*(){return r.encrypt(e,t)})))})}decrypt(e,t,r){return $(this,void 0,void 0,function*(){const i=yield Promise.all(e.map(n=>$(this,void 0,void 0,function*(){return this._accountProvider.decrypt(n,t,r)})));for(const n of i)this.add(n);return this})}save(e,t){return $(this,void 0,void 0,function*(){const r=ne.getStorage();if(!r)throw new Error("Local storage not available.");return r.setItem(t??this._defaultKeyName,JSON.stringify(yield this.encrypt(e))),!0})}load(e,t){return $(this,void 0,void 0,function*(){const r=ne.getStorage();if(!r)throw new Error("Local storage not available.");const i=r.getItem(t??this._defaultKeyName);return i&&(yield this.decrypt(JSON.parse(i)||[],e)),this})}}var te;const M=(te=Qe.secp256k1)!==null&&te!==void 0?te:et,be=BigInt("0xffffffffffffffff"),X=BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),ot=M.CURVE.n,at=ot/BigInt(2),ct={type:"object",required:["crypto","id","version","address"],properties:{crypto:{type:"object",required:["cipher","ciphertext","cipherparams","kdf","kdfparams","mac"],properties:{cipher:{type:"string"},ciphertext:{type:"string"},cipherparams:{type:"object"},kdf:{type:"string"},kdfparams:{type:"object"},salt:{type:"string"},mac:{type:"string"}}},id:{type:"string"},version:{type:"number"},address:{type:"string"}}};var W;(function(s){s[s.Mainnet=1]="Mainnet",s[s.Goerli=5]="Goerli",s[s.Sepolia=11155111]="Sepolia"})(W||(W={}));var v;(function(s){s.Chainstart="chainstart",s.Homestead="homestead",s.Dao="dao",s.TangerineWhistle="tangerineWhistle",s.SpuriousDragon="spuriousDragon",s.Byzantium="byzantium",s.Constantinople="constantinople",s.Petersburg="petersburg",s.Istanbul="istanbul",s.MuirGlacier="muirGlacier",s.Berlin="berlin",s.London="london",s.ArrowGlacier="arrowGlacier",s.GrayGlacier="grayGlacier",s.MergeForkIdTransition="mergeForkIdTransition",s.Merge="merge",s.Shanghai="shanghai",s.ShardingForkDev="shardingFork"})(v||(v={}));var ye;(function(s){s.ProofOfStake="pos",s.ProofOfWork="pow",s.ProofOfAuthority="poa"})(ye||(ye={}));var ke;(function(s){s.Ethash="ethash",s.Clique="clique",s.Casper="casper"})(ke||(ke={}));var S;(function(s){s.PolygonMainnet="polygon-mainnet",s.PolygonMumbai="polygon-mumbai",s.ArbitrumRinkebyTestnet="arbitrum-rinkeby-testnet",s.ArbitrumOne="arbitrum-one",s.xDaiChain="x-dai-chain",s.OptimisticKovan="optimistic-kovan",s.OptimisticEthereum="optimistic-ethereum"})(S||(S={}));var T;(function(s){s[s.Number=0]="Number",s[s.BigInt=1]="BigInt",s[s.Uint8Array=2]="Uint8Array",s[s.PrefixedHexString=3]="PrefixedHexString"})(T||(T={}));const Ce=s=>{if(typeof s!="string")throw new Error(`[stripHexPrefix] input must be type 'string', received ${typeof s}`);return ce(s)?s.slice(2):s};function dt(s){return!s||s==="0x0"?"0x0000000000000000":ce(s)?`0x${Ce(s).padStart(16,"0")}`:`0x${s.padStart(16,"0")}`}const He=function(s){if(!Number.isSafeInteger(s)||s<0)throw new Error(`Received an invalid integer type: ${s}`);return`0x${s.toString(16)}`};function ht(s,e=!0){var t,r;const{name:i,config:n,difficulty:o,mixHash:a,gasLimit:d,coinbase:h,baseFeePerGas:c}=s;let{extraData:l,timestamp:m,nonce:f}=s;const I=Number(m),{chainId:B}=n;if(l===""&&(l="0x"),ce(m)||(m=He(parseInt(m))),f.length!==18&&(f=dt(f)),n.eip155Block!==n.eip158Block)throw new Error("EIP155 block number must equal EIP 158 block number since both are part of SpuriousDragon hardfork and the client only supports activating the full hardfork");const g={name:i,chainId:B,networkId:B,genesis:{timestamp:m,gasLimit:parseInt(d),difficulty:parseInt(o),nonce:f,extraData:l,mixHash:a,coinbase:h,baseFeePerGas:c},hardfork:void 0,hardforks:[],bootstrapNodes:[],consensus:n.clique!==void 0?{type:"poa",algorithm:"clique",clique:{period:(t=n.clique.period)!==null&&t!==void 0?t:n.clique.blockperiodseconds,epoch:(r=n.clique.epoch)!==null&&r!==void 0?r:n.clique.epochlength}}:{type:"pow",algorithm:"ethash",ethash:{}}},w={[v.Homestead]:{name:"homesteadBlock"},[v.Dao]:{name:"daoForkBlock"},[v.TangerineWhistle]:{name:"eip150Block"},[v.SpuriousDragon]:{name:"eip155Block"},[v.Byzantium]:{name:"byzantiumBlock"},[v.Constantinople]:{name:"constantinopleBlock"},[v.Petersburg]:{name:"petersburgBlock"},[v.Istanbul]:{name:"istanbulBlock"},[v.MuirGlacier]:{name:"muirGlacierBlock"},[v.Berlin]:{name:"berlinBlock"},[v.London]:{name:"londonBlock"},[v.MergeForkIdTransition]:{name:"mergeForkBlock",postMerge:e},[v.Shanghai]:{name:"shanghaiTime",postMerge:!0,isTimestamp:!0},[v.ShardingForkDev]:{name:"shardingForkTime",postMerge:!0,isTimestamp:!0}},F=Object.keys(w).reduce((b,_)=>(b[w[_].name]=_,b),{}),Y=Object.keys(n).filter(b=>F[b]!==void 0&&n[b]!==void 0&&n[b]!==null);if(g.hardforks=Y.map(b=>({name:F[b],block:w[F[b]].isTimestamp===!0||typeof n[b]!="number"?null:n[b],timestamp:w[F[b]].isTimestamp===!0&&typeof n[b]=="number"?n[b]:void 0})).filter(b=>b.block!==null||b.timestamp!==void 0),g.hardforks.sort((b,_)=>{var O,C;return((O=b.block)!==null&&O!==void 0?O:1/0)-((C=_.block)!==null&&C!==void 0?C:1/0)}),g.hardforks.sort((b,_)=>{var O,C;return((O=b.timestamp)!==null&&O!==void 0?O:I)-((C=_.timestamp)!==null&&C!==void 0?C:I)}),n.terminalTotalDifficulty!==void 0){const b={name:v.Merge,ttd:n.terminalTotalDifficulty,block:null},_=g.hardforks.findIndex(O=>{var C;return((C=w[O.name])===null||C===void 0?void 0:C.postMerge)===!0});_!==-1?g.hardforks.splice(_,0,b):g.hardforks.push(b)}const z=g.hardforks.length>0?g.hardforks.slice(-1)[0]:void 0;return g.hardfork=z==null?void 0:z.name,g.hardforks.unshift({name:v.Chainstart,block:0}),g}function lt(s,e,t){try{if(["config","difficulty","gasLimit","alloc"].some(r=>!(r in s)))throw new Error("Invalid format, expected geth genesis fields missing");return e!==void 0&&(s.name=e),ht(s,t)}catch(r){throw new Error(`Error parsing parameters file: ${r.message}`)}}function Le(s){let e=s;if(typeof e!="string")throw new Error(`[padToEven] value must be type 'string', received ${typeof e}`);return e.length%2&&(e=`0${e}`),e}const ft=function(s){const e=He(s);return P(`0x${Le(e.slice(2))}`)},y=function(s){if(s==null)return new Uint8Array;if(s instanceof Uint8Array)return s;if(Array.isArray(s))return Uint8Array.from(s);if(typeof s=="string"){if(!Pe(s))throw new Error(`Cannot convert string to Uint8Array. only supports 0x-prefixed hex strings and this string was given: ${s}`);return P(Le(Ce(s)))}if(typeof s=="number")return y(Te(s));if(typeof s=="bigint"){if(s<BigInt(0))throw new Error(`Cannot convert negative bigint to Uint8Array. Given: ${s}`);let e=s.toString(16);return e.length%2&&(e=`0${e}`),y(`0x${e}`)}if(s.toArray)return Uint8Array.from(s.toArray());throw new Error("invalid type")};function p(s){const e=E(s);return BigInt(e==="0x"?0:e)}function ut(s){return y(`0x${s.toString(16)}`)}const _e=function(s){return new Uint8Array(s).fill(0)},mt=function(s,e,t){const r=_e(e);return t?s.length<e?(r.set(s),r):s.subarray(0,e):s.length<e?(r.set(s,e-s.length),r):s.subarray(-e)};function ue(s){if(!(s instanceof Uint8Array)){const e=`This method only supports Uint8Array but input was: ${s}`;throw new Error(e)}}const Ee=function(s,e){return ue(s),mt(s,e,!1)};function gt(s){let e=s[0];for(;s.length>0&&e.toString()==="0";)s=s.slice(1),e=s[0];return s}const Z=function(s){return ue(s),gt(s)},k=s=>`0x${s.toString(16)}`;function u(s){return Z(ut(s))}function pt(s,e){return s===BigInt(0)||s===BigInt(1)?s:e===void 0?s-BigInt(27):s-(e*BigInt(2)+BigInt(35))}function vt(s){return s===BigInt(0)||s===BigInt(1)}const me=function(s,e,t,r,i){const n=pt(e,i);if(!vt(n))throw new Error("Invalid signature v value");return new M.Signature(p(t),p(r)).addRecoveryBit(Number(n)).recoverPublicKey(s).toRawBytes(!1).slice(1)};function K(s,e){if(s===null)return null;if(s===void 0)return;if(typeof s=="string"&&!Pe(s))throw new Error(`A string must be provided with a 0x-prefix, given: ${s}`);if(typeof s=="number"&&!Number.isSafeInteger(s))throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)");const t=y(s);switch(e){case T.Uint8Array:return t;case T.BigInt:return p(t);case T.Number:{const r=p(t);if(r>BigInt(Number.MAX_SAFE_INTEGER))throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)");return Number(r)}case T.PrefixedHexString:return E(t);default:throw new Error("unknown outputType")}}const bt={name:"goerli",chainId:5,networkId:5,defaultHardfork:"merge",consensus:{type:"poa",algorithm:"clique",clique:{period:15,epoch:3e4}},comment:"Cross-client PoA test network",url:"https://github.com/goerli/testnet",genesis:{timestamp:"0x5c51a607",gasLimit:10485760,difficulty:1,nonce:"0x0000000000000000",extraData:"0x22466c6578692069732061207468696e6722202d204166726900000000000000e0a2bd4258d2768837baa26a28fe71dc079f84c70000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"},hardforks:[{name:"chainstart",block:0,forkHash:"0xa3f5ab08"},{name:"homestead",block:0,forkHash:"0xa3f5ab08"},{name:"tangerineWhistle",block:0,forkHash:"0xa3f5ab08"},{name:"spuriousDragon",block:0,forkHash:"0xa3f5ab08"},{name:"byzantium",block:0,forkHash:"0xa3f5ab08"},{name:"constantinople",block:0,forkHash:"0xa3f5ab08"},{name:"petersburg",block:0,forkHash:"0xa3f5ab08"},{name:"istanbul",block:1561651,forkHash:"0xc25efa5c"},{name:"berlin",block:4460644,forkHash:"0x757a1c47"},{name:"london",block:5062605,forkHash:"0xb8c6299d"},{"//_comment":"The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://goerli.etherscan.io/block/7382818",name:"merge",ttd:"10790000",block:7382819,forkHash:"0xb8c6299d"},{name:"mergeForkIdTransition",block:null,forkHash:null},{name:"shanghai",block:null,forkHash:null}],bootstrapNodes:[],dnsNetworks:["enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.goerli.ethdisco.net"]},yt={name:"mainnet",chainId:1,networkId:1,defaultHardfork:"merge",consensus:{type:"pow",algorithm:"ethash",ethash:{}},comment:"The Ethereum main chain",url:"https://ethstats.net/",genesis:{gasLimit:5e3,difficulty:17179869184,nonce:"0x0000000000000042",extraData:"0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa"},hardforks:[{name:"chainstart",block:0,forkHash:"0xfc64ec04"},{name:"homestead",block:115e4,forkHash:"0x97c2c34c"},{name:"dao",block:192e4,forkHash:"0x91d1f948"},{name:"tangerineWhistle",block:2463e3,forkHash:"0x7a64da13"},{name:"spuriousDragon",block:2675e3,forkHash:"0x3edd5b10"},{name:"byzantium",block:437e4,forkHash:"0xa00bc324"},{name:"constantinople",block:728e4,forkHash:"0x668db0af"},{name:"petersburg",block:728e4,forkHash:"0x668db0af"},{name:"istanbul",block:9069e3,forkHash:"0x879d6e30"},{name:"muirGlacier",block:92e5,forkHash:"0xe029e991"},{name:"berlin",block:12244e3,forkHash:"0x0eb440f6"},{name:"london",block:12965e3,forkHash:"0xb715077d"},{name:"arrowGlacier",block:13773e3,forkHash:"0x20c327fc"},{name:"grayGlacier",block:1505e4,forkHash:"0xf0afd0e3"},{"//_comment":"The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://etherscan.io/block/15537393",name:"merge",ttd:"58750000000000000000000",block:15537394,forkHash:"0xf0afd0e3"},{name:"mergeForkIdTransition",block:null,forkHash:null},{name:"shanghai",block:null,forkHash:null}],bootstrapNodes:[],dnsNetworks:["enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.mainnet.ethdisco.net"]},kt={name:"sepolia",chainId:11155111,networkId:11155111,defaultHardfork:"merge",consensus:{type:"pow",algorithm:"ethash",ethash:{}},comment:"PoW test network to replace Ropsten",url:"https://github.com/ethereum/go-ethereum/pull/23730",genesis:{timestamp:"0x6159af19",gasLimit:3e7,difficulty:131072,nonce:"0x0000000000000000",extraData:"0x5365706f6c69612c20417468656e732c204174746963612c2047726565636521"},hardforks:[{name:"chainstart",block:0,forkHash:"0xfe3366e7"},{name:"homestead",block:0,forkHash:"0xfe3366e7"},{name:"tangerineWhistle",block:0,forkHash:"0xfe3366e7"},{name:"spuriousDragon",block:0,forkHash:"0xfe3366e7"},{name:"byzantium",block:0,forkHash:"0xfe3366e7"},{name:"constantinople",block:0,forkHash:"0xfe3366e7"},{name:"petersburg",block:0,forkHash:"0xfe3366e7"},{name:"istanbul",block:0,forkHash:"0xfe3366e7"},{name:"muirGlacier",block:0,forkHash:"0xfe3366e7"},{name:"berlin",block:0,forkHash:"0xfe3366e7"},{name:"london",block:0,forkHash:"0xfe3366e7"},{"//_comment":"The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://sepolia.etherscan.io/block/1450408",name:"merge",ttd:"17000000000000000",block:1450409,forkHash:"0xfe3366e7"},{name:"mergeForkIdTransition",block:1735371,forkHash:"0xb96cbd13"},{name:"shanghai",block:null,timestamp:"1677557088",forkHash:"0xf7f9bc08"}],bootstrapNodes:[],dnsNetworks:["enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.sepolia.ethdisco.net"]},Et={name:"EIP-1153",number:1153,comment:"Transient Storage",url:"https://eips.ethereum.org/EIPS/eip-1153",status:"Review",minimumHardfork:"chainstart",requiredEIPs:[],gasConfig:{},gasPrices:{tstore:{v:100,d:"Base fee of the TSTORE opcode"},tload:{v:100,d:"Base fee of the TLOAD opcode"}},vm:{},pow:{}},wt={name:"EIP-1559",number:1559,comment:"Fee market change for ETH 1.0 chain",url:"https://eips.ethereum.org/EIPS/eip-1559",status:"Final",minimumHardfork:"berlin",requiredEIPs:[2930],gasConfig:{baseFeeMaxChangeDenominator:{v:8,d:"Maximum base fee change denominator"},elasticityMultiplier:{v:2,d:"Maximum block gas target elasticity"},initialBaseFee:{v:1e9,d:"Initial base fee on first EIP1559 block"}},gasPrices:{},vm:{},pow:{}},It={name:"EIP-2315",number:2315,comment:"Simple subroutines for the EVM",url:"https://eips.ethereum.org/EIPS/eip-2315",status:"Draft",minimumHardfork:"istanbul",gasConfig:{},gasPrices:{beginsub:{v:2,d:"Base fee of the BEGINSUB opcode"},returnsub:{v:5,d:"Base fee of the RETURNSUB opcode"},jumpsub:{v:10,d:"Base fee of the JUMPSUB opcode"}},vm:{},pow:{}},Pt={name:"EIP-2537",number:2537,comment:"BLS12-381 precompiles",url:"https://eips.ethereum.org/EIPS/eip-2537",status:"Draft",minimumHardfork:"chainstart",gasConfig:{},gasPrices:{Bls12381G1AddGas:{v:600,d:"Gas cost of a single BLS12-381 G1 addition precompile-call"},Bls12381G1MulGas:{v:12e3,d:"Gas cost of a single BLS12-381 G1 multiplication precompile-call"},Bls12381G2AddGas:{v:4500,d:"Gas cost of a single BLS12-381 G2 addition precompile-call"},Bls12381G2MulGas:{v:55e3,d:"Gas cost of a single BLS12-381 G2 multiplication precompile-call"},Bls12381PairingBaseGas:{v:115e3,d:"Base gas cost of BLS12-381 pairing check"},Bls12381PairingPerPairGas:{v:23e3,d:"Per-pair gas cost of BLS12-381 pairing check"},Bls12381MapG1Gas:{v:5500,d:"Gas cost of BLS12-381 map field element to G1"},Bls12381MapG2Gas:{v:11e4,d:"Gas cost of BLS12-381 map field element to G2"},Bls12381MultiExpGasDiscount:{v:[[1,1200],[2,888],[3,764],[4,641],[5,594],[6,547],[7,500],[8,453],[9,438],[10,423],[11,408],[12,394],[13,379],[14,364],[15,349],[16,334],[17,330],[18,326],[19,322],[20,318],[21,314],[22,310],[23,306],[24,302],[25,298],[26,294],[27,289],[28,285],[29,281],[30,277],[31,273],[32,269],[33,268],[34,266],[35,265],[36,263],[37,262],[38,260],[39,259],[40,257],[41,256],[42,254],[43,253],[44,251],[45,250],[46,248],[47,247],[48,245],[49,244],[50,242],[51,241],[52,239],[53,238],[54,236],[55,235],[56,233],[57,232],[58,231],[59,229],[60,228],[61,226],[62,225],[63,223],[64,222],[65,221],[66,220],[67,219],[68,219],[69,218],[70,217],[71,216],[72,216],[73,215],[74,214],[75,213],[76,213],[77,212],[78,211],[79,211],[80,210],[81,209],[82,208],[83,208],[84,207],[85,206],[86,205],[87,205],[88,204],[89,203],[90,202],[91,202],[92,201],[93,200],[94,199],[95,199],[96,198],[97,197],[98,196],[99,196],[100,195],[101,194],[102,193],[103,193],[104,192],[105,191],[106,191],[107,190],[108,189],[109,188],[110,188],[111,187],[112,186],[113,185],[114,185],[115,184],[116,183],[117,182],[118,182],[119,181],[120,180],[121,179],[122,179],[123,178],[124,177],[125,176],[126,176],[127,175],[128,174]],d:"Discount gas costs of calls to the MultiExp precompiles with `k` (point, scalar) pair"}},vm:{},pow:{}},St={name:"EIP-2565",number:2565,comment:"ModExp gas cost",url:"https://eips.ethereum.org/EIPS/eip-2565",status:"Final",minimumHardfork:"byzantium",gasConfig:{},gasPrices:{modexpGquaddivisor:{v:3,d:"Gquaddivisor from modexp precompile for gas calculation"}},vm:{},pow:{}},xt={name:"EIP-2718",comment:"Typed Transaction Envelope",url:"https://eips.ethereum.org/EIPS/eip-2718",status:"Final",minimumHardfork:"chainstart",gasConfig:{},gasPrices:{},vm:{},pow:{}},Bt={name:"EIP-2929",comment:"Gas cost increases for state access opcodes",url:"https://eips.ethereum.org/EIPS/eip-2929",status:"Final",minimumHardfork:"chainstart",gasConfig:{},gasPrices:{coldsload:{v:2100,d:"Gas cost of the first read of storage from a given location (per transaction)"},coldaccountaccess:{v:2600,d:"Gas cost of the first read of a given address (per transaction)"},warmstorageread:{v:100,d:"Gas cost of reading storage locations which have already loaded 'cold'"},sstoreCleanGasEIP2200:{v:2900,d:"Once per SSTORE operation from clean non-zero to something else"},sstoreNoopGasEIP2200:{v:100,d:"Once per SSTORE operation if the value doesn't change"},sstoreDirtyGasEIP2200:{v:100,d:"Once per SSTORE operation if a dirty value is changed"},sstoreInitRefundEIP2200:{v:19900,d:"Once per SSTORE operation for resetting to the original zero value"},sstoreCleanRefundEIP2200:{v:4900,d:"Once per SSTORE operation for resetting to the original non-zero value"},call:{v:0,d:"Base fee of the CALL opcode"},callcode:{v:0,d:"Base fee of the CALLCODE opcode"},delegatecall:{v:0,d:"Base fee of the DELEGATECALL opcode"},staticcall:{v:0,d:"Base fee of the STATICCALL opcode"},balance:{v:0,d:"Base fee of the BALANCE opcode"},extcodesize:{v:0,d:"Base fee of the EXTCODESIZE opcode"},extcodecopy:{v:0,d:"Base fee of the EXTCODECOPY opcode"},extcodehash:{v:0,d:"Base fee of the EXTCODEHASH opcode"},sload:{v:0,d:"Base fee of the SLOAD opcode"},sstore:{v:0,d:"Base fee of the SSTORE opcode"}},vm:{},pow:{}},At={name:"EIP-2930",comment:"Optional access lists",url:"https://eips.ethereum.org/EIPS/eip-2930",status:"Final",minimumHardfork:"istanbul",requiredEIPs:[2718,2929],gasConfig:{},gasPrices:{accessListStorageKeyCost:{v:1900,d:"Gas cost per storage key in an Access List transaction"},accessListAddressCost:{v:2400,d:"Gas cost per storage key in an Access List transaction"}},vm:{},pow:{}},Tt={name:"EIP-3198",number:3198,comment:"BASEFEE opcode",url:"https://eips.ethereum.org/EIPS/eip-3198",status:"Final",minimumHardfork:"london",gasConfig:{},gasPrices:{basefee:{v:2,d:"Gas cost of the BASEFEE opcode"}},vm:{},pow:{}},Ct={name:"EIP-3529",comment:"Reduction in refunds",url:"https://eips.ethereum.org/EIPS/eip-3529",status:"Final",minimumHardfork:"berlin",requiredEIPs:[2929],gasConfig:{maxRefundQuotient:{v:5,d:"Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)"}},gasPrices:{selfdestructRefund:{v:0,d:"Refunded following a selfdestruct operation"},sstoreClearRefundEIP2200:{v:4800,d:"Once per SSTORE operation for clearing an originally existing storage slot"}},vm:{},pow:{}},Ht={name:"EIP-3540",number:3540,comment:"EVM Object Format (EOF) v1",url:"https://eips.ethereum.org/EIPS/eip-3540",status:"Review",minimumHardfork:"london",requiredEIPs:[3541],gasConfig:{},gasPrices:{},vm:{},pow:{}},Lt={name:"EIP-3541",comment:"Reject new contracts starting with the 0xEF byte",url:"https://eips.ethereum.org/EIPS/eip-3541",status:"Final",minimumHardfork:"berlin",requiredEIPs:[],gasConfig:{},gasPrices:{},vm:{},pow:{}},_t={name:"EIP-3554",comment:"Reduction in refunds",url:"Difficulty Bomb Delay to December 1st 2021",status:"Final",minimumHardfork:"muirGlacier",requiredEIPs:[],gasConfig:{},gasPrices:{},vm:{},pow:{difficultyBombDelay:{v:95e5,d:"the amount of blocks to delay the difficulty bomb with"}}},Ot={name:"EIP-3607",number:3607,comment:"Reject transactions from senders with deployed code",url:"https://eips.ethereum.org/EIPS/eip-3607",status:"Final",minimumHardfork:"chainstart",requiredEIPs:[],gasConfig:{},gasPrices:{},vm:{},pow:{}},Dt={name:"EIP-3651",number:3198,comment:"Warm COINBASE",url:"https://eips.ethereum.org/EIPS/eip-3651",status:"Review",minimumHardfork:"london",requiredEIPs:[2929],gasConfig:{},gasPrices:{},vm:{},pow:{}},Rt={name:"EIP-3670",number:3670,comment:"EOF - Code Validation",url:"https://eips.ethereum.org/EIPS/eip-3670",status:"Review",minimumHardfork:"london",requiredEIPs:[3540],gasConfig:{},gasPrices:{},vm:{},pow:{}},Ft={name:"EIP-3675",number:3675,comment:"Upgrade consensus to Proof-of-Stake",url:"https://eips.ethereum.org/EIPS/eip-3675",status:"Final",minimumHardfork:"london",requiredEIPs:[],gasConfig:{},gasPrices:{},vm:{},pow:{}},Gt={name:"EIP-3855",number:3855,comment:"PUSH0 instruction",url:"https://eips.ethereum.org/EIPS/eip-3855",status:"Review",minimumHardfork:"chainstart",requiredEIPs:[],gasConfig:{},gasPrices:{push0:{v:2,d:"Base fee of the PUSH0 opcode"}},vm:{},pow:{}},Mt={name:"EIP-3860",number:3860,comment:"Limit and meter initcode",url:"https://eips.ethereum.org/EIPS/eip-3860",status:"Review",minimumHardfork:"spuriousDragon",requiredEIPs:[],gasConfig:{},gasPrices:{initCodeWordCost:{v:2,d:"Gas to pay for each word (32 bytes) of initcode when creating a contract"}},vm:{maxInitCodeSize:{v:49152,d:"Maximum length of initialization code when creating a contract"}},pow:{}},Nt={name:"EIP-4345",number:4345,comment:"Difficulty Bomb Delay to June 2022",url:"https://eips.ethereum.org/EIPS/eip-4345",status:"Final",minimumHardfork:"london",gasConfig:{},gasPrices:{},vm:{},pow:{difficultyBombDelay:{v:107e5,d:"the amount of blocks to delay the difficulty bomb with"}}},Ut={name:"EIP-4399",number:4399,comment:"Supplant DIFFICULTY opcode with PREVRANDAO",url:"https://eips.ethereum.org/EIPS/eip-4399",status:"Review",minimumHardfork:"london",requiredEIPs:[],gasConfig:{},gasPrices:{},vm:{},pow:{}},zt={name:"EIP-5133",number:5133,comment:"Delaying Difficulty Bomb to mid-September 2022",url:"https://eips.ethereum.org/EIPS/eip-5133",status:"Draft",minimumHardfork:"grayGlacier",gasConfig:{},gasPrices:{},vm:{},pow:{difficultyBombDelay:{v:114e5,d:"the amount of blocks to delay the difficulty bomb with"}}},j={1153:Et,1559:wt,2315:It,2537:Pt,2565:St,2718:xt,2929:Bt,2930:At,3198:Tt,3529:Ct,3540:Ht,3541:Lt,3554:_t,3607:Ot,3651:Dt,3670:Rt,3675:Ft,3855:Gt,3860:Mt,4345:Nt,4399:Ut,5133:zt},$t={name:"chainstart",comment:"Start of the Ethereum main chain",url:"",status:"",gasConfig:{minGasLimit:{v:5e3,d:"Minimum the gas limit may ever be"},gasLimitBoundDivisor:{v:1024,d:"The bound divisor of the gas limit, used in update calculations"},maxRefundQuotient:{v:2,d:"Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)"}},gasPrices:{base:{v:2,d:"Gas base cost, used e.g. for ChainID opcode (Istanbul)"},tierStep:{v:[0,2,3,5,8,10,20],d:"Once per operation, for a selection of them"},exp:{v:10,d:"Base fee of the EXP opcode"},expByte:{v:10,d:"Times ceil(log256(exponent)) for the EXP instruction"},sha3:{v:30,d:"Base fee of the SHA3 opcode"},sha3Word:{v:6,d:"Once per word of the SHA3 operation's data"},sload:{v:50,d:"Base fee of the SLOAD opcode"},sstoreSet:{v:2e4,d:"Once per SSTORE operation if the zeroness changes from zero"},sstoreReset:{v:5e3,d:"Once per SSTORE operation if the zeroness does not change from zero"},sstoreRefund:{v:15e3,d:"Once per SSTORE operation if the zeroness changes to zero"},jumpdest:{v:1,d:"Base fee of the JUMPDEST opcode"},log:{v:375,d:"Base fee of the LOG opcode"},logData:{v:8,d:"Per byte in a LOG* operation's data"},logTopic:{v:375,d:"Multiplied by the * of the LOG*, per LOG transaction. e.g. LOG0 incurs 0 * c_txLogTopicGas, LOG4 incurs 4 * c_txLogTopicGas"},create:{v:32e3,d:"Base fee of the CREATE opcode"},call:{v:40,d:"Base fee of the CALL opcode"},callStipend:{v:2300,d:"Free gas given at beginning of call"},callValueTransfer:{v:9e3,d:"Paid for CALL when the value transfor is non-zero"},callNewAccount:{v:25e3,d:"Paid for CALL when the destination address didn't exist prior"},selfdestructRefund:{v:24e3,d:"Refunded following a selfdestruct operation"},memory:{v:3,d:"Times the address of the (highest referenced byte in memory + 1). NOTE: referencing happens on read, write and in instructions such as RETURN and CALL"},quadCoeffDiv:{v:512,d:"Divisor for the quadratic particle of the memory cost equation"},createData:{v:200,d:""},tx:{v:21e3,d:"Per transaction. NOTE: Not payable on data of calls between transactions"},txCreation:{v:32e3,d:"The cost of creating a contract via tx"},txDataZero:{v:4,d:"Per byte of data attached to a transaction that equals zero. NOTE: Not payable on data of calls between transactions"},txDataNonZero:{v:68,d:"Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions"},copy:{v:3,d:"Multiplied by the number of 32-byte words that are copied (round up) for any *COPY operation and added"},ecRecover:{v:3e3,d:""},sha256:{v:60,d:""},sha256Word:{v:12,d:""},ripemd160:{v:600,d:""},ripemd160Word:{v:120,d:""},identity:{v:15,d:""},identityWord:{v:3,d:""},stop:{v:0,d:"Base fee of the STOP opcode"},add:{v:3,d:"Base fee of the ADD opcode"},mul:{v:5,d:"Base fee of the MUL opcode"},sub:{v:3,d:"Base fee of the SUB opcode"},div:{v:5,d:"Base fee of the DIV opcode"},sdiv:{v:5,d:"Base fee of the SDIV opcode"},mod:{v:5,d:"Base fee of the MOD opcode"},smod:{v:5,d:"Base fee of the SMOD opcode"},addmod:{v:8,d:"Base fee of the ADDMOD opcode"},mulmod:{v:8,d:"Base fee of the MULMOD opcode"},signextend:{v:5,d:"Base fee of the SIGNEXTEND opcode"},lt:{v:3,d:"Base fee of the LT opcode"},gt:{v:3,d:"Base fee of the GT opcode"},slt:{v:3,d:"Base fee of the SLT opcode"},sgt:{v:3,d:"Base fee of the SGT opcode"},eq:{v:3,d:"Base fee of the EQ opcode"},iszero:{v:3,d:"Base fee of the ISZERO opcode"},and:{v:3,d:"Base fee of the AND opcode"},or:{v:3,d:"Base fee of the OR opcode"},xor:{v:3,d:"Base fee of the XOR opcode"},not:{v:3,d:"Base fee of the NOT opcode"},byte:{v:3,d:"Base fee of the BYTE opcode"},address:{v:2,d:"Base fee of the ADDRESS opcode"},balance:{v:20,d:"Base fee of the BALANCE opcode"},origin:{v:2,d:"Base fee of the ORIGIN opcode"},caller:{v:2,d:"Base fee of the CALLER opcode"},callvalue:{v:2,d:"Base fee of the CALLVALUE opcode"},calldataload:{v:3,d:"Base fee of the CALLDATALOAD opcode"},calldatasize:{v:2,d:"Base fee of the CALLDATASIZE opcode"},calldatacopy:{v:3,d:"Base fee of the CALLDATACOPY opcode"},codesize:{v:2,d:"Base fee of the CODESIZE opcode"},codecopy:{v:3,d:"Base fee of the CODECOPY opcode"},gasprice:{v:2,d:"Base fee of the GASPRICE opcode"},extcodesize:{v:20,d:"Base fee of the EXTCODESIZE opcode"},extcodecopy:{v:20,d:"Base fee of the EXTCODECOPY opcode"},blockhash:{v:20,d:"Base fee of the BLOCKHASH opcode"},coinbase:{v:2,d:"Base fee of the COINBASE opcode"},timestamp:{v:2,d:"Base fee of the TIMESTAMP opcode"},number:{v:2,d:"Base fee of the NUMBER opcode"},difficulty:{v:2,d:"Base fee of the DIFFICULTY opcode"},gaslimit:{v:2,d:"Base fee of the GASLIMIT opcode"},pop:{v:2,d:"Base fee of the POP opcode"},mload:{v:3,d:"Base fee of the MLOAD opcode"},mstore:{v:3,d:"Base fee of the MSTORE opcode"},mstore8:{v:3,d:"Base fee of the MSTORE8 opcode"},sstore:{v:0,d:"Base fee of the SSTORE opcode"},jump:{v:8,d:"Base fee of the JUMP opcode"},jumpi:{v:10,d:"Base fee of the JUMPI opcode"},pc:{v:2,d:"Base fee of the PC opcode"},msize:{v:2,d:"Base fee of the MSIZE opcode"},gas:{v:2,d:"Base fee of the GAS opcode"},push:{v:3,d:"Base fee of the PUSH opcode"},dup:{v:3,d:"Base fee of the DUP opcode"},swap:{v:3,d:"Base fee of the SWAP opcode"},callcode:{v:40,d:"Base fee of the CALLCODE opcode"},return:{v:0,d:"Base fee of the RETURN opcode"},invalid:{v:0,d:"Base fee of the INVALID opcode"},selfdestruct:{v:0,d:"Base fee of the SELFDESTRUCT opcode"}},vm:{stackLimit:{v:1024,d:"Maximum size of VM stack allowed"},callCreateDepth:{v:1024,d:"Maximum depth of call/create stack"},maxExtraDataSize:{v:32,d:"Maximum size extra data may be after Genesis"}},pow:{minimumDifficulty:{v:131072,d:"The minimum that the difficulty may ever be"},difficultyBoundDivisor:{v:2048,d:"The bound divisor of the difficulty, used in the update calculations"},durationLimit:{v:13,d:"The decision boundary on the blocktime duration used to determine whether difficulty should go up or not"},epochDuration:{v:3e4,d:"Duration between proof-of-work epochs"},timebombPeriod:{v:1e5,d:"Exponential difficulty timebomb period"},minerReward:{v:"5000000000000000000",d:"the amount a miner get rewarded for mining a block"},difficultyBombDelay:{v:0,d:"the amount of blocks to delay the difficulty bomb with"}}},Kt={name:"dao",comment:"DAO rescue hardfork",url:"https://eips.ethereum.org/EIPS/eip-779",status:"Final",gasConfig:{},gasPrices:{},vm:{},pow:{}},jt={name:"homestead",comment:"Homestead hardfork with protocol and network changes",url:"https://eips.ethereum.org/EIPS/eip-606",status:"Final",gasConfig:{},gasPrices:{delegatecall:{v:40,d:"Base fee of the DELEGATECALL opcode"}},vm:{},pow:{}},qt={name:"tangerineWhistle",comment:"Hardfork with gas cost changes for IO-heavy operations",url:"https://eips.ethereum.org/EIPS/eip-608",status:"Final",gasConfig:{},gasPrices:{sload:{v:200,d:"Once per SLOAD operation"},call:{v:700,d:"Once per CALL operation & message call transaction"},extcodesize:{v:700,d:"Base fee of the EXTCODESIZE opcode"},extcodecopy:{v:700,d:"Base fee of the EXTCODECOPY opcode"},balance:{v:400,d:"Base fee of the BALANCE opcode"},delegatecall:{v:700,d:"Base fee of the DELEGATECALL opcode"},callcode:{v:700,d:"Base fee of the CALLCODE opcode"},selfdestruct:{v:5e3,d:"Base fee of the SELFDESTRUCT opcode"}},vm:{},pow:{}},Vt={name:"spuriousDragon",comment:"HF with EIPs for simple replay attack protection, EXP cost increase, state trie clearing, contract code size limit",url:"https://eips.ethereum.org/EIPS/eip-607",status:"Final",gasConfig:{},gasPrices:{expByte:{v:50,d:"Times ceil(log256(exponent)) for the EXP instruction"}},vm:{maxCodeSize:{v:24576,d:"Maximum length of contract code"}},pow:{}},Jt={name:"byzantium",comment:"Hardfork with new precompiles, instructions and other protocol changes",url:"https://eips.ethereum.org/EIPS/eip-609",status:"Final",gasConfig:{},gasPrices:{modexpGquaddivisor:{v:20,d:"Gquaddivisor from modexp precompile for gas calculation"},ecAdd:{v:500,d:"Gas costs for curve addition precompile"},ecMul:{v:4e4,d:"Gas costs for curve multiplication precompile"},ecPairing:{v:1e5,d:"Base gas costs for curve pairing precompile"},ecPairingWord:{v:8e4,d:"Gas costs regarding curve pairing precompile input length"},revert:{v:0,d:"Base fee of the REVERT opcode"},staticcall:{v:700,d:"Base fee of the STATICCALL opcode"},returndatasize:{v:2,d:"Base fee of the RETURNDATASIZE opcode"},returndatacopy:{v:3,d:"Base fee of the RETURNDATACOPY opcode"}},vm:{},pow:{minerReward:{v:"3000000000000000000",d:"the amount a miner get rewarded for mining a block"},difficultyBombDelay:{v:3e6,d:"the amount of blocks to delay the difficulty bomb with"}}},Yt={name:"constantinople",comment:"Postponed hardfork including EIP-1283 (SSTORE gas metering changes)",url:"https://eips.ethereum.org/EIPS/eip-1013",status:"Final",gasConfig:{},gasPrices:{netSstoreNoopGas:{v:200,d:"Once per SSTORE operation if the value doesn't change"},netSstoreInitGas:{v:2e4,d:"Once per SSTORE operation from clean zero"},netSstoreCleanGas:{v:5e3,d:"Once per SSTORE operation from clean non-zero"},netSstoreDirtyGas:{v:200,d:"Once per SSTORE operation from dirty"},netSstoreClearRefund:{v:15e3,d:"Once per SSTORE operation for clearing an originally existing storage slot"},netSstoreResetRefund:{v:4800,d:"Once per SSTORE operation for resetting to the original non-zero value"},netSstoreResetClearRefund:{v:19800,d:"Once per SSTORE operation for resetting to the original zero value"},shl:{v:3,d:"Base fee of the SHL opcode"},shr:{v:3,d:"Base fee of the SHR opcode"},sar:{v:3,d:"Base fee of the SAR opcode"},extcodehash:{v:400,d:"Base fee of the EXTCODEHASH opcode"},create2:{v:32e3,d:"Base fee of the CREATE2 opcode"}},vm:{},pow:{minerReward:{v:"2000000000000000000",d:"The amount a miner gets rewarded for mining a block"},difficultyBombDelay:{v:5e6,d:"the amount of blocks to delay the difficulty bomb with"}}},Xt={name:"petersburg",comment:"Aka constantinopleFix, removes EIP-1283, activate together with or after constantinople",url:"https://eips.ethereum.org/EIPS/eip-1716",status:"Final",gasConfig:{},gasPrices:{netSstoreNoopGas:{v:null,d:"Removed along EIP-1283"},netSstoreInitGas:{v:null,d:"Removed along EIP-1283"},netSstoreCleanGas:{v:null,d:"Removed along EIP-1283"},netSstoreDirtyGas:{v:null,d:"Removed along EIP-1283"},netSstoreClearRefund:{v:null,d:"Removed along EIP-1283"},netSstoreResetRefund:{v:null,d:"Removed along EIP-1283"},netSstoreResetClearRefund:{v:null,d:"Removed along EIP-1283"}},vm:{},pow:{}},Wt={name:"istanbul",comment:"HF targeted for December 2019 following the Constantinople/Petersburg HF",url:"https://eips.ethereum.org/EIPS/eip-1679",status:"Final",gasConfig:{},gasPrices:{blake2Round:{v:1,d:"Gas cost per round for the Blake2 F precompile"},ecAdd:{v:150,d:"Gas costs for curve addition precompile"},ecMul:{v:6e3,d:"Gas costs for curve multiplication precompile"},ecPairing:{v:45e3,d:"Base gas costs for curve pairing precompile"},ecPairingWord:{v:34e3,d:"Gas costs regarding curve pairing precompile input length"},txDataNonZero:{v:16,d:"Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions"},sstoreSentryGasEIP2200:{v:2300,d:"Minimum gas required to be present for an SSTORE call, not consumed"},sstoreNoopGasEIP2200:{v:800,d:"Once per SSTORE operation if the value doesn't change"},sstoreDirtyGasEIP2200:{v:800,d:"Once per SSTORE operation if a dirty value is changed"},sstoreInitGasEIP2200:{v:2e4,d:"Once per SSTORE operation from clean zero to non-zero"},sstoreInitRefundEIP2200:{v:19200,d:"Once per SSTORE operation for resetting to the original zero value"},sstoreCleanGasEIP2200:{v:5e3,d:"Once per SSTORE operation from clean non-zero to something else"},sstoreCleanRefundEIP2200:{v:4200,d:"Once per SSTORE operation for resetting to the original non-zero value"},sstoreClearRefundEIP2200:{v:15e3,d:"Once per SSTORE operation for clearing an originally existing storage slot"},balance:{v:700,d:"Base fee of the BALANCE opcode"},extcodehash:{v:700,d:"Base fee of the EXTCODEHASH opcode"},chainid:{v:2,d:"Base fee of the CHAINID opcode"},selfbalance:{v:5,d:"Base fee of the SELFBALANCE opcode"},sload:{v:800,d:"Base fee of the SLOAD opcode"}},vm:{},pow:{}},Zt={name:"muirGlacier",comment:"HF to delay the difficulty bomb",url:"https://eips.ethereum.org/EIPS/eip-2384",status:"Final",gasConfig:{},gasPrices:{},vm:{},pow:{difficultyBombDelay:{v:9e6,d:"the amount of blocks to delay the difficulty bomb with"}}},Qt={name:"berlin",comment:"HF targeted for July 2020 following the Muir Glacier HF",url:"https://eips.ethereum.org/EIPS/eip-2070",status:"Final",eips:[2565,2929,2718,2930]},er={name:"london",comment:"HF targeted for July 2021 following the Berlin fork",url:"https://github.com/ethereum/eth1.0-specs/blob/master/network-upgrades/mainnet-upgrades/london.md",status:"Final",eips:[1559,3198,3529,3541]},tr={name:"shanghai",comment:"Next feature hardfork after the merge hardfork having withdrawals, warm coinbase, push0, limit/meter initcode",url:"https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/shanghai.md",status:"Final",eips:[3651,3855,3860,4895]},rr={name:"arrowGlacier",comment:"HF to delay the difficulty bomb",url:"https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/arrow-glacier.md",status:"Final",eips:[4345],gasConfig:{},gasPrices:{},vm:{},pow:{}},sr={name:"grayGlacier",comment:"Delaying the difficulty bomb to Mid September 2022",url:"https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/gray-glacier.md",status:"Draft",eips:[5133],gasConfig:{},gasPrices:{},vm:{},pow:{}},ir={name:"mergeForkIdTransition",comment:"Pre-merge hardfork to fork off non-upgraded clients",url:"https://eips.ethereum.org/EIPS/eip-3675",status:"Draft",eips:[]},nr={name:"merge",comment:"Hardfork to upgrade the consensus mechanism to Proof-of-Stake",url:"https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/merge.md",status:"Final",consensus:{type:"pos",algorithm:"casper",casper:{}},eips:[3675,4399]},or={chainstart:$t,homestead:jt,dao:Kt,tangerineWhistle:qt,spuriousDragon:Vt,byzantium:Jt,constantinople:Yt,petersburg:Xt,istanbul:Wt,muirGlacier:Zt,berlin:Qt,london:er,shanghai:tr,arrowGlacier:rr,grayGlacier:sr,mergeForkIdTransition:ir,merge:nr},{buf:ar}=Ue;class x extends ze.EventEmitter{constructor(e){var t,r;super(),this._eips=[],this._customChains=(t=e.customChains)!==null&&t!==void 0?t:[],this._chainParams=this.setChain(e.chain),this.DEFAULT_HARDFORK=(r=this._chainParams.defaultHardfork)!==null&&r!==void 0?r:v.Merge,this.HARDFORK_CHANGES=this.hardforks().map(i=>[i.name,or[i.name]]),this._hardfork=this.DEFAULT_HARDFORK,e.hardfork!==void 0&&this.setHardfork(e.hardfork),e.eips&&this.setEIPs(e.eips)}static custom(e,t={}){var r;const i=(r=t.baseChain)!==null&&r!==void 0?r:"mainnet",n=Object.assign({},x._getChainParams(i));if(n.name="custom-chain",typeof e!="string")return new x(Object.assign({chain:Object.assign(Object.assign({},n),e)},t));if(e===S.PolygonMainnet)return x.custom({name:S.PolygonMainnet,chainId:137,networkId:137},t);if(e===S.PolygonMumbai)return x.custom({name:S.PolygonMumbai,chainId:80001,networkId:80001},t);if(e===S.ArbitrumRinkebyTestnet)return x.custom({name:S.ArbitrumRinkebyTestnet,chainId:421611,networkId:421611},t);if(e===S.ArbitrumOne)return x.custom({name:S.ArbitrumOne,chainId:42161,networkId:42161},t);if(e===S.xDaiChain)return x.custom({name:S.xDaiChain,chainId:100,networkId:100},t);if(e===S.OptimisticKovan)return x.custom({name:S.OptimisticKovan,chainId:69,networkId:69},Object.assign({hardfork:v.Berlin},t));if(e===S.OptimisticEthereum)return x.custom({name:S.OptimisticEthereum,chainId:10,networkId:10},Object.assign({hardfork:v.Berlin},t));throw new Error(`Custom chain ${e} not supported`)}static fromGethGenesis(e,{chain:t,eips:r,genesisHash:i,hardfork:n,mergeForkIdPostMerge:o}){var a;const d=lt(e,t,o),h=new x({chain:(a=d.name)!==null&&a!==void 0?a:"custom",customChains:[d],eips:r,hardfork:n??d.hardfork});return i!==void 0&&h.setForkHashes(i),h}static isSupportedChainId(e){return!!this._getInitializedChains().names[e.toString()]}static _getChainParams(e,t){let r=e;const i=this._getInitializedChains(t);if(typeof r=="number"||typeof r=="bigint"){if(r=r.toString(),i.names[r]){const n=i.names[r];return i[n]}throw new Error(`Chain with ID ${r} not supported`)}if(i[r]!==void 0)return i[r];throw new Error(`Chain with name ${r} not supported`)}setChain(e){if(typeof e=="number"||typeof e=="bigint"||typeof e=="string")this._chainParams=x._getChainParams(e,this._customChains);else if(typeof e=="object"){if(this._customChains.length>0)throw new Error("Chain must be a string, number, or bigint when initialized with customChains passed in");const t=["networkId","genesis","hardforks","bootstrapNodes"];for(const r of t)if(!(r in e))throw new Error(`Missing required chain parameter: ${r}`);this._chainParams=e}else throw new Error("Wrong input format");for(const t of this.hardforks())if(t.block===void 0)throw new Error("Hardfork cannot have undefined block number");return this._chainParams}setHardfork(e){let t=!1;for(const r of this.HARDFORK_CHANGES)r[0]===e&&(this._hardfork!==e&&(this._hardfork=e,this.emit("hardforkChanged",e)),t=!0);if(!t)throw new Error(`Hardfork with name ${e} not supported`)}getHardforkByBlockNumber(e,t,r){const i=K(e,T.BigInt),n=K(t,T.BigInt),o=K(r,T.Number),a=this.hardforks().filter(f=>f.block!==null||f.ttd!==null&&f.ttd!==void 0||f.timestamp!==void 0),d=a.findIndex(f=>f.ttd!==null&&f.ttd!==void 0);if(a.slice(d+1).findIndex(f=>f.ttd!==null&&f.ttd!==void 0)>=0)throw Error("More than one merge hardforks found with ttd specified");let c=a.findIndex(f=>f.block!==null&&f.block>i||o!==void 0&&Number(f.timestamp)>o);if(c===-1)c=a.length;else if(c===0)throw Error("Must have at least one hardfork at block 0");if(o===void 0){const f=a.slice(0,c).reverse().findIndex(I=>I.block!==null||I.ttd!==void 0);c-=f}if(c-=1,a[c].block===null&&a[c].timestamp===void 0)(n==null||BigInt(a[c].ttd)>n)&&(c-=1);else if(d>=0&&n!==void 0&&n!==null){if(c>=d&&BigInt(a[d].ttd)>n)throw Error("Maximum HF determined by total difficulty is lower than the block number HF");if(c<d&&BigInt(a[d].ttd)<=n)throw Error("HF determined by block number is lower than the minimum total difficulty HF")}const l=c;for(;c<a.length-1&&!(a[c].block!==a[c+1].block||a[c].timestamp!==a[c+1].timestamp);c+=1);if(o){if(a.slice(0,l).reduce((B,g)=>{var w;return Math.max(Number((w=g.timestamp)!==null&&w!==void 0?w:"0"),B)},0)>o)throw Error("Maximum HF determined by timestamp is lower than the block number/ttd HF");if(a.slice(c+1).reduce((B,g)=>{var w;return Math.min(Number((w=g.timestamp)!==null&&w!==void 0?w:o),B)},o)<o)throw Error("Maximum HF determined by block number/ttd is lower than timestamp HF")}return a[c].name}setHardforkByBlockNumber(e,t,r){const i=this.getHardforkByBlockNumber(e,t,r);return this.setHardfork(i),i}_getHardfork(e){const t=this.hardforks();for(const r of t)if(r.name===e)return r;return null}setEIPs(e=[]){for(const t of e){if(!(t in j))throw new Error(`${t} not supported`);const r=this.gteHardfork(j[t].minimumHardfork);if(!r)throw new Error(`${t} cannot be activated on hardfork ${this.hardfork()}, minimumHardfork: ${r}`);if(j[t].requiredEIPs!==void 0){for(const i of j[t].requiredEIPs)if(!(e.includes(i)||this.isActivatedEIP(i)))throw new Error(`${t} requires EIP ${i}, but is not included in the EIP list`)}}this._eips=e}param(e,t){let r;for(const i of this._eips)if(r=this.paramByEIP(e,t,i),r!==void 0)return r;return this.paramByHardfork(e,t,this._hardfork)}paramByHardfork(e,t,r){let i=null;for(const n of this.HARDFORK_CHANGES){if("eips"in n[1]){const o=n[1].eips;for(const a of o){const d=this.paramByEIP(e,t,a);i=typeof d=="bigint"?d:i}}else{if(n[1][e]===void 0)throw new Error(`Topic ${e} not defined`);n[1][e][t]!==void 0&&(i=n[1][e][t].v)}if(n[0]===r)break}return BigInt(i??0)}paramByEIP(e,t,r){if(!(r in j))throw new Error(`${r} not supported`);const i=j[r];if(!(e in i))throw new Error(`Topic ${e} not defined`);if(i[e][t]===void 0)return;const n=i[e][t].v;return BigInt(n)}paramByBlock(e,t,r,i,n){const o=this.getHardforkByBlockNumber(r,i,n);return this.paramByHardfork(e,t,o)}isActivatedEIP(e){if(this.eips().includes(e))return!0;for(const t of this.HARDFORK_CHANGES){const r=t[1];if(this.gteHardfork(r.name)&&"eips"in r&&r.eips.includes(e))return!0}return!1}hardforkIsActiveOnBlock(e,t){const r=K(t,T.BigInt),i=e??this._hardfork,n=this.hardforkBlock(i);return typeof n=="bigint"&&n!==BigInt(0)&&r>=n}activeOnBlock(e){return this.hardforkIsActiveOnBlock(null,e)}hardforkGteHardfork(e,t){const r=e??this._hardfork,i=this.hardforks();let n=-1,o=-1,a=0;for(const d of i)d.name===r&&(n=a),d.name===t&&(o=a),a+=1;return n>=o&&o!==-1}gteHardfork(e){return this.hardforkGteHardfork(null,e)}hardforkBlock(e){var t;const r=e??this._hardfork,i=(t=this._getHardfork(r))===null||t===void 0?void 0:t.block;return i==null?null:BigInt(i)}hardforkTimestamp(e){var t;const r=e??this._hardfork,i=(t=this._getHardfork(r))===null||t===void 0?void 0:t.timestamp;return i==null?null:BigInt(i)}eipBlock(e){for(const t of this.HARDFORK_CHANGES){const r=t[1];if("eips"in r&&r.eips.includes(e))return this.hardforkBlock(typeof t[0]=="number"?String(t[0]):t[0])}return null}hardforkTTD(e){var t;const r=e??this._hardfork,i=(t=this._getHardfork(r))===null||t===void 0?void 0:t.ttd;return i==null?null:BigInt(i)}isHardforkBlock(e,t){const r=K(e,T.BigInt),i=t??this._hardfork,n=this.hardforkBlock(i);return typeof n=="bigint"&&n!==BigInt(0)?n===r:!1}nextHardforkBlockOrTimestamp(e){var t,r;const i=e??this._hardfork,n=this.hardforks();let o=n.findIndex(c=>c.name===i);if(i===v.Merge&&(o-=1),o<0)return null;let a=(t=n[o].timestamp)!==null&&t!==void 0?t:n[o].block;a=a!=null?Number(a):null;const d=n.slice(o+1).find(c=>{var l;let m=(l=c.timestamp)!==null&&l!==void 0?l:c.block;return m=m!=null?Number(m):null,c.name!==v.Merge&&m!==null&&m!==void 0&&m!==a});if(d===void 0)return null;const h=(r=d.timestamp)!==null&&r!==void 0?r:d.block;return h==null?null:BigInt(h)}nextHardforkBlock(e){const t=e??this._hardfork;let r=this.hardforkBlock(t);if(r===null&&t===v.Merge){const n=this.hardforks(),o=n.findIndex(a=>a.ttd!==null&&a.ttd!==void 0);if(o<0)throw Error("Merge hardfork should have been found");r=this.hardforkBlock(n[o-1].name)}return r===null?null:this.hardforks().reduce((n,o)=>{const a=BigInt(o.block===null||o.ttd!==void 0&&o.ttd!==null?0:o.block);return a>r&&n===null?a:n},null)}isNextHardforkBlock(e,t){const r=K(e,T.BigInt),i=t??this._hardfork,n=this.nextHardforkBlock(i);return n===null?!1:n===r}_calcForkHash(e,t){let r=new Uint8Array,i=0;for(const a of this.hardforks()){const{block:d,timestamp:h,name:c}=a;let l=h??d;if(l=l!==null?Number(l):null,typeof l=="number"&&l!==0&&l!==i&&c!==v.Merge){const m=P(l.toString(16).padStart(16,"0"));r=R(r,m),i=l}if(a.name===e)break}const n=R(t,r);return E(ft(ar(n)>>>0))}forkHash(e,t){const r=e??this._hardfork,i=this._getHardfork(r);if(i===null||(i==null?void 0:i.block)===null&&(i==null?void 0:i.timestamp)===void 0&&(i==null?void 0:i.ttd)===void 0){const n="No fork hash calculation possible for future hardfork";throw new Error(n)}if((i==null?void 0:i.forkHash)!==null&&(i==null?void 0:i.forkHash)!==void 0)return i.forkHash;if(!t)throw new Error("genesisHash required for forkHash calculation");return this._calcForkHash(r,t)}hardforkForForkHash(e){const t=this.hardforks().filter(r=>r.forkHash===e);return t.length>=1?t[t.length-1]:null}setForkHashes(e){var t;for(const r of this.hardforks()){const i=(t=r.timestamp)!==null&&t!==void 0?t:r.block;(r.forkHash===null||r.forkHash===void 0)&&(i!=null||typeof r.ttd<"u")&&(r.forkHash=this.forkHash(r.name,e))}}genesis(){return this._chainParams.genesis}hardforks(){return this._chainParams.hardforks}bootstrapNodes(){return this._chainParams.bootstrapNodes}dnsNetworks(){return this._chainParams.dnsNetworks}hardfork(){return this._hardfork}chainId(){return BigInt(this._chainParams.chainId)}chainName(){return this._chainParams.name}networkId(){return BigInt(this._chainParams.networkId)}eips(){return this._eips}consensusType(){const e=this.hardfork();let t;for(const r of this.HARDFORK_CHANGES)if("consensus"in r[1]&&(t=r[1].consensus.type),r[0]===e)break;return t??this._chainParams.consensus.type}consensusAlgorithm(){const e=this.hardfork();let t;for(const r of this.HARDFORK_CHANGES)if("consensus"in r[1]&&(t=r[1].consensus.algorithm),r[0]===e)break;return t??this._chainParams.consensus.algorithm}consensusConfig(){var e;const t=this.hardfork();let r;for(const i of this.HARDFORK_CHANGES)if("consensus"in i[1]&&(r=i[1].consensus[i[1].consensus.algorithm]),i[0]===t)break;return(e=r??this._chainParams.consensus[this.consensusAlgorithm()])!==null&&e!==void 0?e:{}}copy(){const e=Object.assign(Object.create(Object.getPrototypeOf(this)),this);return e.removeAllListeners(),e}static _getInitializedChains(e){const t={};for(const[i,n]of Object.entries(W))t[n]=i.toLowerCase();const r={mainnet:yt,goerli:bt,sepolia:kt};if(e)for(const i of e){const{name:n}=i;t[i.chainId.toString()]=n,r[n]=i}return r.names=t,r}}var L;(function(s){s[s.EIP155ReplayProtection=155]="EIP155ReplayProtection",s[s.EIP1559FeeMarket=1559]="EIP1559FeeMarket",s[s.EIP2718TypedTransaction=2718]="EIP2718TypedTransaction",s[s.EIP2930AccessLists=2930]="EIP2930AccessLists"})(L||(L={}));function cr(s){if(s.length===0)return!0;const e=s[0];return!!Array.isArray(e)}function dr(s){return!cr(s)}class q{constructor(e){if(e.length!==20)throw new Error("Invalid address length");this.buf=e}static zero(){return new q(_e(20))}equals(e){return he(this.buf,e.buf)}isZero(){return this.equals(q.zero())}toString(){return E(this.buf)}toArray(){return this.buf}static publicToAddress(e,t=!1){let r=e;if(ue(r),t&&r.length!==64&&(r=M.ProjectivePoint.fromHex(r).toRawBytes(!1).slice(1)),r.length!==64)throw new Error("Expected pubKey to be of length 64");return H(r).slice(-20)}}const hr=(s,e)=>{const t=s.param("vm","maxInitCodeSize");if(t&&BigInt(e)>t)throw new Error(`the initcode size of this transaction is too large: it is ${e} while the max is ${s.param("vm","maxInitCodeSize")}`)},Oe=s=>{let e,t;if(dr(s)){e=s;const r=[];for(let i=0;i<s.length;i+=1){const n=s[i],o=y(n.address),a=[];for(let d=0;d<n.storageKeys.length;d+=1)a.push(y(n.storageKeys[d]));r.push([o,a])}t=r}else{t=s??[];const r=[];for(let i=0;i<t.length;i+=1){const n=t[i],o=E(n[0]),a=[];for(let h=0;h<n[1].length;h+=1)a.push(E(n[1][h]));const d={address:o,storageKeys:a};r.push(d)}e=r}return{AccessListJSON:e,accessList:t}},De=s=>{for(let e=0;e<s.length;e+=1){const t=s[e],r=t[0],i=t[1];if(t[2]!==void 0)throw new Error("Access list item cannot have 3 elements. It can only have an address, and an array of storage slots.");if(r.length!==20)throw new Error("Invalid EIP-2930 transaction: address length should be 20 bytes");for(let n=0;n<i.length;n+=1)if(i[n].length!==32)throw new Error("Invalid EIP-2930 transaction: storage slot length should be 32 bytes")}},Re=s=>{const e=[];for(let t=0;t<s.length;t+=1){const r=s[t],i={address:E(Ee(r[0],20)),storageKeys:[]},n=r&&r[1];for(let o=0;o<n.length;o+=1){const a=n[o];i.storageKeys.push(E(Ee(a,32)))}e.push(i)}return e},Fe=(s,e)=>{const t=e.param("gasPrices","accessListStorageKeyCost"),r=e.param("gasPrices","accessListAddressCost");let i=0;for(let o=0;o<s.length;o+=1){const d=s[o][1];i+=d.length}return s.length*Number(r)+i*Number(t)};class V{constructor(e,t){var r,i;this.cache={hash:void 0,dataFee:void 0},this.activeCapabilities=[],this.DEFAULT_CHAIN=W.Mainnet,this.DEFAULT_HARDFORK=v.Merge;const{nonce:n,gasLimit:o,to:a,value:d,data:h,v:c,r:l,s:m,type:f}=e;this._type=Number(p(y(f))),this.txOptions=t;const I=y(a===""?"0x":a),B=y(c===""?"0x":c),g=y(l===""?"0x":l),w=y(m===""?"0x":m);this.nonce=p(y(n===""?"0x":n)),this.gasLimit=p(y(o===""?"0x":o)),this.to=I.length>0?new q(I):void 0,this.value=p(y(d===""?"0x":d)),this.data=y(h===""?"0x":h),this.v=B.length>0?p(B):void 0,this.r=g.length>0?p(g):void 0,this.s=w.length>0?p(w):void 0,this._validateCannotExceedMaxInteger({value:this.value,r:this.r,s:this.s}),this._validateCannotExceedMaxInteger({gasLimit:this.gasLimit},64),this._validateCannotExceedMaxInteger({nonce:this.nonce},64,!0);const F=this.to===void 0||this.to===null,Y=(r=t.allowUnlimitedInitCodeSize)!==null&&r!==void 0?r:!1,z=(i=t.common)!==null&&i!==void 0?i:this._getCommon();F&&z.isActivatedEIP(3860)&&!Y&&hr(z,this.data.length)}get type(){return this._type}supports(e){return this.activeCapabilities.includes(e)}validate(e=!1){const t=[];return this.getBaseFee()>this.gasLimit&&t.push(`gasLimit is too low. given ${this.gasLimit}, need at least ${this.getBaseFee()}`),this.isSigned()&&!this.verifySignature()&&t.push("Invalid Signature"),e?t:t.length===0}_validateYParity(){const{v:e}=this;if(e!==void 0&&e!==BigInt(0)&&e!==BigInt(1)){const t=this._errorMsg("The y-parity of the transaction should either be 0 or 1");throw new Error(t)}}_validateHighS(){const{s:e}=this;if(this.common.gteHardfork("homestead")&&e!==void 0&&e>at){const t=this._errorMsg("Invalid Signature: s-values greater than secp256k1n/2 are considered invalid");throw new Error(t)}}getBaseFee(){const e=this.common.param("gasPrices","tx");let t=this.getDataFee();if(e&&(t+=e),this.common.gteHardfork("homestead")&&this.toCreationAddress()){const r=this.common.param("gasPrices","txCreation");r&&(t+=r)}return t}getDataFee(){const e=this.common.param("gasPrices","txDataZero"),t=this.common.param("gasPrices","txDataNonZero");let r=BigInt(0);for(let i=0;i<this.data.length;i+=1)this.data[i]===0?r+=e:r+=t;if((this.to===void 0||this.to===null)&&this.common.isActivatedEIP(3860)){const i=BigInt(Math.ceil(this.data.length/32)),n=this.common.param("gasPrices","initCodeWordCost")*i;r+=n}return r}toCreationAddress(){return this.to===void 0||this.to.buf.length===0}isSigned(){const{v:e,r:t,s:r}=this;return!(e===void 0||t===void 0||r===void 0)}verifySignature(){try{const e=this.getSenderPublicKey();return Z(e).length!==0}catch{return!1}}getSenderAddress(){return new q(q.publicToAddress(this.getSenderPublicKey()))}sign(e){if(e.length!==32){const d=this._errorMsg("Private key must be 32 bytes in length.");throw new Error(d)}let t=!1;this.type===0&&this.common.gteHardfork("spuriousDragon")&&!this.supports(L.EIP155ReplayProtection)&&(this.activeCapabilities.push(L.EIP155ReplayProtection),t=!0);const r=this.getMessageToSign(!0),{v:i,r:n,s:o}=this._ecsign(r,e),a=this._processSignature(i,n,o);if(t){const d=this.activeCapabilities.indexOf(L.EIP155ReplayProtection);d>-1&&this.activeCapabilities.splice(d,1)}return a}_getCommon(e,t){var r;if(t!==void 0){const i=p(y(t));if(e){if(e.chainId()!==i){const n=this._errorMsg("The chain ID does not match the chain ID of Common");throw new Error(n)}return e.copy()}return x.isSupportedChainId(i)?new x({chain:i,hardfork:this.DEFAULT_HARDFORK}):x.custom({name:"custom-chain",networkId:i,chainId:i},{baseChain:this.DEFAULT_CHAIN,hardfork:this.DEFAULT_HARDFORK})}return(r=e==null?void 0:e.copy())!==null&&r!==void 0?r:new x({chain:this.DEFAULT_CHAIN,hardfork:this.DEFAULT_HARDFORK})}_validateCannotExceedMaxInteger(e,t=256,r=!1){for(const[i,n]of Object.entries(e))switch(t){case 64:if(r){if(n!==void 0&&n>=be){const o=this._errorMsg(`${i} cannot equal or exceed MAX_UINT64 (2^64-1), given ${n}`);throw new Error(o)}}else if(n!==void 0&&n>be){const o=this._errorMsg(`${i} cannot exceed MAX_UINT64 (2^64-1), given ${n}`);throw new Error(o)}break;case 256:if(r){if(n!==void 0&&n>=X){const o=this._errorMsg(`${i} cannot equal or exceed MAX_INTEGER (2^256-1), given ${n}`);throw new Error(o)}}else if(n!==void 0&&n>X){const o=this._errorMsg(`${i} cannot exceed MAX_INTEGER (2^256-1), given ${n}`);throw new Error(o)}break;default:{const o=this._errorMsg("unimplemented bits value");throw new Error(o)}}}static _validateNotArray(e){const t=["nonce","gasPrice","gasLimit","to","value","data","v","r","s","type","baseFee","maxFeePerGas","chainId"];for(const[r,i]of Object.entries(e))if(t.includes(r)&&Array.isArray(i))throw new Error(`${r} cannot be an array`)}_getSharedErrorPostfix(){let e="";try{e=this.isSigned()?E(this.hash()):"not available (unsigned)"}catch{e="error"}let t="";try{t=this.isSigned().toString()}catch{e="error"}let r="";try{r=this.common.hardfork()}catch{r="error"}let i=`tx type=${this.type} hash=${e} nonce=${this.nonce} value=${this.value} `;return i+=`signed=${t} hf=${r}`,i}_ecsign(e,t,r){const i=M.sign(e,t),n=i.toCompactRawBytes(),o=n.subarray(0,32),a=n.subarray(32,64),d=r===void 0?BigInt(i.recovery+27):BigInt(i.recovery+35)+BigInt(r)*BigInt(2);return{r:o,s:a,v:d}}}const oe=2,re=P(oe.toString(16).padStart(2,"0"));class N extends V{constructor(e,t={}){var r;super(Object.assign(Object.assign({},e),{type:oe}),t),this.DEFAULT_HARDFORK="london";const{chainId:i,accessList:n,maxFeePerGas:o,maxPriorityFeePerGas:a}=e;if(this.common=this._getCommon(t.common,i),this.chainId=this.common.chainId(),!this.common.isActivatedEIP(1559))throw new Error("EIP-1559 not enabled on Common");this.activeCapabilities=this.activeCapabilities.concat([1559,2718,2930]);const d=Oe(n??[]);if(this.accessList=d.accessList,this.AccessListJSON=d.AccessListJSON,De(this.accessList),this.maxFeePerGas=p(y(o===""?"0x":o)),this.maxPriorityFeePerGas=p(y(a===""?"0x":a)),this._validateCannotExceedMaxInteger({maxFeePerGas:this.maxFeePerGas,maxPriorityFeePerGas:this.maxPriorityFeePerGas}),V._validateNotArray(e),this.gasLimit*this.maxFeePerGas>X){const c=this._errorMsg("gasLimit * maxFeePerGas cannot exceed MAX_INTEGER (2^256-1)");throw new Error(c)}if(this.maxFeePerGas<this.maxPriorityFeePerGas){const c=this._errorMsg("maxFeePerGas cannot be less than maxPriorityFeePerGas (The total must be the larger of the two)");throw new Error(c)}this._validateYParity(),this._validateHighS(),((r=t==null?void 0:t.freeze)!==null&&r!==void 0?r:!0)&&Object.freeze(this)}static fromTxData(e,t={}){return new N(e,t)}static fromSerializedTx(e,t={}){if(!he(e.subarray(0,1),re))throw new Error(`Invalid serialized tx input: not an EIP-1559 transaction (wrong tx type, expected: ${oe}, received: ${E(e.subarray(0,1))}`);const r=A.decode(e.subarray(1));if(!Array.isArray(r))throw new Error("Invalid serialized tx input: must be array");return N.fromValuesArray(r,t)}static fromValuesArray(e,t={}){if(e.length!==9&&e.length!==12)throw new Error("Invalid EIP-1559 transaction. Only expecting 9 values (for unsigned tx) or 12 values (for signed tx).");const[r,i,n,o,a,d,h,c,l,m,f,I]=e;return this._validateNotArray({chainId:r,v:m}),de({nonce:i,maxPriorityFeePerGas:n,maxFeePerGas:o,gasLimit:a,value:h,v:m,r:f,s:I}),new N({chainId:p(r),nonce:i,maxPriorityFeePerGas:n,maxFeePerGas:o,gasLimit:a,to:d,value:h,data:c,accessList:l??[],v:m!==void 0?p(m):void 0,r:f,s:I},t)}getDataFee(){if(this.cache.dataFee&&this.cache.dataFee.hardfork===this.common.hardfork())return this.cache.dataFee.value;let e=super.getDataFee();return e+=BigInt(Fe(this.accessList,this.common)),Object.isFrozen(this)&&(this.cache.dataFee={value:e,hardfork:this.common.hardfork()}),e}getUpfrontCost(e=BigInt(0)){const t=this.maxPriorityFeePerGas,r=this.maxFeePerGas-e,n=(t<r?t:r)+e;return this.gasLimit*n+this.value}raw(){return[u(this.chainId),u(this.nonce),u(this.maxPriorityFeePerGas),u(this.maxFeePerGas),u(this.gasLimit),this.to!==void 0?this.to.buf:Uint8Array.from([]),u(this.value),this.data,this.accessList,this.v!==void 0?u(this.v):Uint8Array.from([]),this.r!==void 0?u(this.r):Uint8Array.from([]),this.s!==void 0?u(this.s):Uint8Array.from([])]}serialize(){const e=this.raw();return R(re,A.encode(e))}getMessageToSign(e=!0){const t=this.raw().slice(0,9),r=R(re,A.encode(t));return e?H(r):r}hash(){if(!this.isSigned()){const e=this._errorMsg("Cannot call hash method if transaction is not signed");throw new Error(e)}return Object.isFrozen(this)?(this.cache.hash||(this.cache.hash=H(this.serialize())),this.cache.hash):H(this.serialize())}getMessageToVerifySignature(){return this.getMessageToSign()}getSenderPublicKey(){if(!this.isSigned()){const n=this._errorMsg("Cannot call this method if transaction is not signed");throw new Error(n)}const e=this.getMessageToVerifySignature(),{v:t,r,s:i}=this;this._validateHighS();try{return me(e,t+BigInt(27),u(r),u(i))}catch{const o=this._errorMsg("Invalid Signature");throw new Error(o)}}_processSignature(e,t,r){const i=Object.assign(Object.assign({},this.txOptions),{common:this.common});return N.fromTxData({chainId:this.chainId,nonce:this.nonce,maxPriorityFeePerGas:this.maxPriorityFeePerGas,maxFeePerGas:this.maxFeePerGas,gasLimit:this.gasLimit,to:this.to,value:this.value,data:this.data,accessList:this.accessList,v:e-BigInt(27),r:p(t),s:p(r)},i)}toJSON(){const e=Re(this.accessList);return{chainId:k(this.chainId),nonce:k(this.nonce),maxPriorityFeePerGas:k(this.maxPriorityFeePerGas),maxFeePerGas:k(this.maxFeePerGas),gasLimit:k(this.gasLimit),to:this.to!==void 0?this.to.toString():void 0,value:k(this.value),data:E(this.data),accessList:e,v:this.v!==void 0?k(this.v):void 0,r:this.r!==void 0?k(this.r):void 0,s:this.s!==void 0?k(this.s):void 0}}errorStr(){let e=this._getSharedErrorPostfix();return e+=` maxFeePerGas=${this.maxFeePerGas} maxPriorityFeePerGas=${this.maxPriorityFeePerGas}`,e}_errorMsg(e){return`${e} (${this.errorStr()})`}}const ae=1,se=P(ae.toString(16).padStart(2,"0"));class U extends V{constructor(e,t={}){var r;super(Object.assign(Object.assign({},e),{type:ae}),t),this.DEFAULT_HARDFORK="berlin";const{chainId:i,accessList:n,gasPrice:o}=e;if(this.common=this._getCommon(t.common,i),this.chainId=this.common.chainId(),!this.common.isActivatedEIP(2930))throw new Error("EIP-2930 not enabled on Common");this.activeCapabilities=this.activeCapabilities.concat([2718,2930]);const a=Oe(n??[]);if(this.accessList=a.accessList,this.AccessListJSON=a.AccessListJSON,De(this.accessList),this.gasPrice=p(y(o===""?"0x":o)),this._validateCannotExceedMaxInteger({gasPrice:this.gasPrice}),V._validateNotArray(e),this.gasPrice*this.gasLimit>X){const h=this._errorMsg("gasLimit * gasPrice cannot exceed MAX_INTEGER");throw new Error(h)}this._validateYParity(),this._validateHighS(),((r=t==null?void 0:t.freeze)!==null&&r!==void 0?r:!0)&&Object.freeze(this)}static fromTxData(e,t={}){return new U(e,t)}static fromSerializedTx(e,t={}){if(!he(e.subarray(0,1),se))throw new Error(`Invalid serialized tx input: not an EIP-2930 transaction (wrong tx type, expected: ${ae}, received: ${E(e.subarray(0,1))}`);const r=A.decode(Uint8Array.from(e.subarray(1)));if(!Array.isArray(r))throw new Error("Invalid serialized tx input: must be array");return U.fromValuesArray(r,t)}static fromValuesArray(e,t={}){if(e.length!==8&&e.length!==11)throw new Error("Invalid EIP-2930 transaction. Only expecting 8 values (for unsigned tx) or 11 values (for signed tx).");const[r,i,n,o,a,d,h,c,l,m,f]=e;this._validateNotArray({chainId:r,v:l}),de({nonce:i,gasPrice:n,gasLimit:o,value:d,v:l,r:m,s:f});const I=[];return new U({chainId:p(r),nonce:i,gasPrice:n,gasLimit:o,to:a,value:d,data:h,accessList:c??I,v:l!==void 0?p(l):void 0,r:m,s:f},t)}getDataFee(){if(this.cache.dataFee&&this.cache.dataFee.hardfork===this.common.hardfork())return this.cache.dataFee.value;let e=super.getDataFee();return e+=BigInt(Fe(this.accessList,this.common)),Object.isFrozen(this)&&(this.cache.dataFee={value:e,hardfork:this.common.hardfork()}),e}getUpfrontCost(){return this.gasLimit*this.gasPrice+this.value}raw(){return[u(this.chainId),u(this.nonce),u(this.gasPrice),u(this.gasLimit),this.to!==void 0?this.to.buf:Uint8Array.from([]),u(this.value),this.data,this.accessList,this.v!==void 0?u(this.v):Uint8Array.from([]),this.r!==void 0?u(this.r):Uint8Array.from([]),this.s!==void 0?u(this.s):Uint8Array.from([])]}serialize(){const e=this.raw();return R(se,A.encode(e))}getMessageToSign(e=!0){const t=this.raw().slice(0,8),r=R(se,A.encode(t));return e?H(r):r}hash(){if(!this.isSigned()){const e=this._errorMsg("Cannot call hash method if transaction is not signed");throw new Error(e)}return Object.isFrozen(this)?(this.cache.hash||(this.cache.hash=H(this.serialize())),this.cache.hash):H(this.serialize())}getMessageToVerifySignature(){return this.getMessageToSign()}getSenderPublicKey(){if(!this.isSigned()){const n=this._errorMsg("Cannot call this method if transaction is not signed");throw new Error(n)}const e=this.getMessageToVerifySignature(),{v:t,r,s:i}=this;this._validateHighS();try{return me(e,t+BigInt(27),u(r),u(i))}catch{const o=this._errorMsg("Invalid Signature");throw new Error(o)}}_processSignature(e,t,r){const i=Object.assign(Object.assign({},this.txOptions),{common:this.common});return U.fromTxData({chainId:this.chainId,nonce:this.nonce,gasPrice:this.gasPrice,gasLimit:this.gasLimit,to:this.to,value:this.value,data:this.data,accessList:this.accessList,v:e-BigInt(27),r:p(t),s:p(r)},i)}toJSON(){const e=Re(this.accessList);return{chainId:k(this.chainId),nonce:k(this.nonce),gasPrice:k(this.gasPrice),gasLimit:k(this.gasLimit),to:this.to!==void 0?this.to.toString():void 0,value:k(this.value),data:E(this.data),accessList:e,v:this.v!==void 0?k(this.v):void 0,r:this.r!==void 0?k(this.r):void 0,s:this.s!==void 0?k(this.s):void 0}}errorStr(){var e,t;let r=this._getSharedErrorPostfix();return r+=` gasPrice=${this.gasPrice} accessListCount=${(t=(e=this.accessList)===null||e===void 0?void 0:e.length)!==null&&t!==void 0?t:0}`,r}_errorMsg(e){return`${e} (${this.errorStr()})`}}const lr=0;function we(s,e){const t=Number(s),r=Number(e)*2;return t===r+35||t===r+36}class G extends V{constructor(e,t={}){var r;if(super(Object.assign(Object.assign({},e),{type:lr}),t),this.common=this._validateTxV(this.v,t.common),this.gasPrice=p(y(e.gasPrice===""?"0x":e.gasPrice)),this.gasPrice*this.gasLimit>X){const n=this._errorMsg("gas limit * gasPrice cannot exceed MAX_INTEGER (2^256-1)");throw new Error(n)}this._validateCannotExceedMaxInteger({gasPrice:this.gasPrice}),V._validateNotArray(e),this.common.gteHardfork("spuriousDragon")&&(this.isSigned()?we(this.v,this.common.chainId())&&this.activeCapabilities.push(L.EIP155ReplayProtection):this.activeCapabilities.push(L.EIP155ReplayProtection)),((r=t==null?void 0:t.freeze)!==null&&r!==void 0?r:!0)&&Object.freeze(this)}static fromTxData(e,t={}){return new G(e,t)}static fromSerializedTx(e,t={}){const r=A.decode(e);if(!Array.isArray(r))throw new Error("Invalid serialized tx input. Must be array");return this.fromValuesArray(r,t)}static fromValuesArray(e,t={}){if(e.length!==6&&e.length!==9)throw new Error("Invalid transaction. Only expecting 6 values (for unsigned tx) or 9 values (for signed tx).");const[r,i,n,o,a,d,h,c,l]=e;return de({nonce:r,gasPrice:i,gasLimit:n,value:a,v:h,r:c,s:l}),new G({nonce:r,gasPrice:i,gasLimit:n,to:o,value:a,data:d,v:h,r:c,s:l},t)}raw(){return[u(this.nonce),u(this.gasPrice),u(this.gasLimit),this.to!==void 0?this.to.buf:Uint8Array.from([]),u(this.value),this.data,this.v!==void 0?u(this.v):Uint8Array.from([]),this.r!==void 0?u(this.r):Uint8Array.from([]),this.s!==void 0?u(this.s):Uint8Array.from([])]}serialize(){return A.encode(this.raw())}_getMessageToSign(){const e=[u(this.nonce),u(this.gasPrice),u(this.gasLimit),this.to!==void 0?this.to.buf:Uint8Array.from([]),u(this.value),this.data];return this.supports(L.EIP155ReplayProtection)&&(e.push(y(this.common.chainId())),e.push(Z(y(0))),e.push(Z(y(0)))),e}getMessageToSign(e=!0){const t=this._getMessageToSign();return e?H(A.encode(t)):t}getDataFee(){return this.cache.dataFee&&this.cache.dataFee.hardfork===this.common.hardfork()?this.cache.dataFee.value:(Object.isFrozen(this)&&(this.cache.dataFee={value:super.getDataFee(),hardfork:this.common.hardfork()}),super.getDataFee())}getUpfrontCost(){return this.gasLimit*this.gasPrice+this.value}hash(){if(!this.isSigned()){const e=this._errorMsg("Cannot call hash method if transaction is not signed");throw new Error(e)}return Object.isFrozen(this)?(this.cache.hash||(this.cache.hash=H(A.encode(this.raw()))),this.cache.hash):H(A.encode(this.raw()))}getMessageToVerifySignature(){if(!this.isSigned()){const t=this._errorMsg("This transaction is not signed");throw new Error(t)}const e=this._getMessageToSign();return H(A.encode(e))}getSenderPublicKey(){const e=this.getMessageToVerifySignature(),{v:t,r,s:i}=this;this._validateHighS();try{return me(e,t,u(r),u(i),this.supports(L.EIP155ReplayProtection)?this.common.chainId():void 0)}catch{const o=this._errorMsg("Invalid Signature");throw new Error(o)}}_processSignature(e,t,r){let i=e;this.supports(L.EIP155ReplayProtection)&&(i+=this.common.chainId()*BigInt(2)+BigInt(8));const n=Object.assign(Object.assign({},this.txOptions),{common:this.common});return G.fromTxData({nonce:this.nonce,gasPrice:this.gasPrice,gasLimit:this.gasLimit,to:this.to,value:this.value,data:this.data,v:i,r:p(t),s:p(r)},n)}toJSON(){return{nonce:k(this.nonce),gasPrice:k(this.gasPrice),gasLimit:k(this.gasLimit),to:this.to!==void 0?this.to.toString():void 0,value:k(this.value),data:E(this.data),v:this.v!==void 0?k(this.v):void 0,r:this.r!==void 0?k(this.r):void 0,s:this.s!==void 0?k(this.s):void 0}}_validateTxV(e,t){let r;const i=e!==void 0?Number(e):void 0;if(i!==void 0&&i<37&&i!==27&&i!==28)throw new Error(`Legacy txs need either v = 27/28 or v >= 37 (EIP-155 replay protection), got v = ${i}`);if(i!==void 0&&i!==0&&(!t||t.gteHardfork("spuriousDragon"))&&i!==27&&i!==28)if(t){if(!we(BigInt(i),t.chainId()))throw new Error(`Incompatible EIP155-based V ${i} and chain id ${t.chainId()}. See the Common parameter of the Transaction constructor to set the chain id.`)}else{let n;(i-35)%2===0?n=35:n=36,r=BigInt(i-n)/BigInt(2)}return this._getCommon(t,r)}errorStr(){let e=this._getSharedErrorPostfix();return e+=` gasPrice=${this.gasPrice}`,e}_errorMsg(e){return`${e} (${this.errorStr()})`}}class fr{constructor(){}static fromTxData(e,t={}){if(!("type"in e)||e.type===void 0)return G.fromTxData(e,t);const r=Number(p(y(e.type)));if(r===0)return G.fromTxData(e,t);if(r===1)return U.fromTxData(e,t);if(r===2)return N.fromTxData(e,t);throw new Error(`Tx instantiation with type ${r} not supported`)}static fromSerializedData(e,t={}){if(e[0]<=127)switch(e[0]){case 1:return U.fromSerializedTx(e,t);case 2:return N.fromSerializedTx(e,t);default:throw new Error(`TypedTransaction with ID ${e[0]} unknown`)}else return G.fromSerializedTx(e,t)}static fromBlockBodyData(e,t={}){if(e instanceof Uint8Array)return this.fromSerializedData(e,t);if(Array.isArray(e))return G.fromValuesArray(e,t);throw new Error("Cannot decode transaction: unknown type input")}}var Q=globalThis&&globalThis.__awaiter||function(s,e,t,r){function i(n){return n instanceof t?n:new t(function(o){o(n)})}return new(t||(t=Promise))(function(n,o){function a(c){try{h(r.next(c))}catch(l){o(l)}}function d(c){try{h(r.throw(c))}catch(l){o(l)}}function h(c){c.done?n(c.value):i(c.value).then(a,d)}h((r=r.apply(s,e||[])).next())})};const ee=(s,e)=>{let t;if(!e&&typeof s=="string"&&Se(s)&&s.length!==66)throw new pe;try{t=s instanceof Uint8Array?s:nt(s)}catch{throw new Ye}if(!e&&t.byteLength!==32)throw new pe;return t},Ge=s=>{const e=Se(s)?s:le(s),t=P(e),r=P(st(`Ethereum Signed Message:
${t.byteLength}`)),i=R(r,t);return J(i)},ur=(s,e)=>{const t=ee(e),r=Ge(s),i=M.sign(r.substring(2),t),n=i.toCompactRawBytes(),o=i.r.toString(16),a=i.s.toString(16),d=i.recovery+27;return{message:s,messageHash:r,v:Te(d),r:`0x${o}`,s:`0x${a}`,signature:`${E(n)}${d.toString(16)}`}},Pr=(s,e)=>Q(void 0,void 0,void 0,function*(){const t=s.sign(P(e));if(D(t.v)||D(t.r)||D(t.s))throw new ie("Signer Error");const r=t.validate(!0);if(r.length>0){let o="Signer Error ";for(const a of r)o+=`${o} ${a}.`;throw new ie(o)}const i=E(t.serialize()),n=J(i);return{messageHash:E(t.getMessageToSign(!0)),v:`0x${t.v.toString(16)}`,r:`0x${t.r.toString(16)}`,s:`0x${t.s.toString(16)}`,rawTransaction:i,transactionHash:E(n)}}),Sr=s=>{if(D(s))throw new Ke;const e=fr.fromSerializedData(P(s));return fe(e.getSenderAddress().toString())},Ie=(s,e,t,r,i)=>{if(typeof s=="object"){const l=`${s.r}${s.s.slice(2)}${s.v.slice(2)}`;return Ie(s.messageHash,l,t)}if(typeof e=="string"&&typeof t=="string"&&!D(r)){const l=`${t}${r.slice(2)}${e.slice(2)}`;return Ie(s,l,i)}if(D(e))throw new je("signature string undefined");const n=130,o=t?s:Ge(s),a=e.substring(n),d=M.Signature.fromCompact(e.slice(2,n)).addRecoveryBit(parseInt(a,16)-27).recoverPublicKey(o.replace("0x","")).toRawBytes(!1),h=J(d.subarray(1));return fe(`0x${h.slice(-40)}`)},Me=s=>{const e=ee(s),t=M.getPublicKey(e,!1),i=J(t.slice(1)).slice(-40);return fe(`0x${i}`)},mr=(s,e,t)=>Q(void 0,void 0,void 0,function*(){var r,i,n,o,a,d,h;const c=ee(s);let l;if(t!=null&&t.salt?l=typeof t.salt=="string"?P(t.salt):t.salt:l=ve(32),!($e(e)||e instanceof Uint8Array))throw new qe;const m=typeof e=="string"?P(le(e)):e;let f;if(t!=null&&t.iv){if(f=typeof t.iv=="string"?P(t.iv):t.iv,f.length!==16)throw new Ve}else f=ve(16);const I=(r=t==null?void 0:t.kdf)!==null&&r!==void 0?r:"scrypt";let B,g;if(I==="pbkdf2"){if(g={dklen:(i=t==null?void 0:t.dklen)!==null&&i!==void 0?i:32,salt:E(l).replace("0x",""),c:(n=t==null?void 0:t.c)!==null&&n!==void 0?n:262144,prf:"hmac-sha256"},g.c<1e3)throw new Je;B=Be(m,l,g.c,g.dklen,"sha256")}else if(I==="scrypt")g={n:(o=t==null?void 0:t.n)!==null&&o!==void 0?o:8192,r:(a=t==null?void 0:t.r)!==null&&a!==void 0?a:8,p:(d=t==null?void 0:t.p)!==null&&d!==void 0?d:1,dklen:(h=t==null?void 0:t.dklen)!==null&&h!==void 0?h:32,salt:E(l).replace("0x","")},B=Ae(m,l,g.n,g.p,g.r,g.dklen);else throw new xe;const w=yield tt(c,B.slice(0,16),f,"aes-128-ctr"),F=E(w).slice(2),Y=J(R(B.slice(16,32),w)).replace("0x","");return{version:3,id:it(),address:Me(c).toLowerCase().replace("0x",""),crypto:{ciphertext:F,cipherparams:{iv:E(f).replace("0x","")},cipher:"aes-128-ctr",kdf:I,kdfparams:g,mac:Y}}}),Ne=(s,e)=>{const t=ee(s,e);return{address:Me(t),privateKey:E(t),signTransaction:r=>{throw new ie("Do not have network access to sign the transaction")},sign:r=>ur(typeof r=="string"?r:JSON.stringify(r),t),encrypt:(r,i)=>Q(void 0,void 0,void 0,function*(){return mr(t,r,i)})}},xr=()=>{const s=M.utils.randomPrivateKey();return Ne(`${E(s)}`)},Br=(s,e,t)=>Q(void 0,void 0,void 0,function*(){const r=typeof s=="object"?s:JSON.parse(t?s.toLowerCase():s);if(ge.validateJSONSchema(ct,r),r.version!==3)throw new Xe;const i=typeof e=="string"?P(le(e)):e;ge.validate(["bytes"],[i]);let n;if(r.crypto.kdf==="scrypt"){const h=r.crypto.kdfparams,c=typeof h.salt=="string"?P(h.salt):h.salt;n=Ae(i,c,h.n,h.p,h.r,h.dklen)}else if(r.crypto.kdf==="pbkdf2"){const h=r.crypto.kdfparams,c=typeof h.salt=="string"?P(h.salt):h.salt;n=Be(i,c,h.c,h.dklen,"sha256")}else throw new xe;const o=P(r.crypto.ciphertext);if(J(R(n.slice(16,32),o)).replace("0x","")!==r.crypto.mac)throw new We;const d=yield rt(P(r.crypto.ciphertext),n.slice(0,16),P(r.crypto.cipherparams.iv));return Ne(d)});export{x as C,fr as T,ne as W,Ie as a,Pr as b,xr as c,Br as d,mr as e,Me as f,Ge as h,Ne as p,Sr as r,ur as s};
